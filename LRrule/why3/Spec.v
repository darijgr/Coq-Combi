(* This file is generated by Why3's coq-ssreflect driver *)
(* Beware! Only edit allowed sections below    *)
Require Import ssrint.
Class WhyType T := {
  why_inhabitant : T ;
  why_decidable_eq : forall x y : T, { x = y } + { x <> y }
}.
Global Instance int_WhyType : WhyType int.
Admitted.

Require Import ssralg ssrnum.
Import GRing.Theory Num.Theory.
Local Open Scope ring_scope.


(* Why3 assumption *)
Definition unit := unit.

Axiom qtmark : Type.
Parameter qtmark_WhyType : WhyType qtmark.
Existing Instance qtmark_WhyType.

Parameter set: forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  (a -> b)%type -> a -> b -> (a -> b)%type.

Axiom Select_eq : forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (m:(a -> b)%type), forall (a1:a) (a2:a), forall (b1:b), (a1 = a2) ->
  (((set m a1 b1) a2) = b1).

Axiom Select_neq : forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, forall (m:(a -> b)%type), forall (a1:a) (a2:a),
  forall (b1:b), (~ (a1 = a2)) -> (((set m a1 b1) a2) = (m a2)).

Parameter const: forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  b -> (a -> b)%type.

(* Why3 assumption *)
Inductive array (a:Type) :=
  | mk_array : int -> (int -> a)%type -> array a.
Axiom array_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.
Implicit Arguments mk_array [[a]].

(* Why3 assumption *)
Definition elts {a:Type} {a_WT:WhyType a} (v:(array a)): (int -> a)%type :=
  match v with
  | (mk_array x x1) => x1
  end.

(* Why3 assumption *)
Definition length {a:Type} {a_WT:WhyType a} (v:(array a)): int :=
  match v with
  | (mk_array x x1) => x
  end.

(* Why3 assumption *)
Definition get1 {a:Type} {a_WT:WhyType a} (a1:(array a)) (i:int): a :=
  ((elts a1) i).

(* Why3 assumption *)
Definition set1 {a:Type} {a_WT:WhyType a} (a1:(array a)) (i:int)
  (v:a): (array a) := (mk_array (length a1) (set (elts a1) i v)).

(* Why3 assumption *)
Definition make {a:Type} {a_WT:WhyType a} (n:int) (v:a): (array a) :=
  (mk_array n (const v: (int -> a)%type)).

Axiom func : forall (a:Type) (b:Type), Type.
Parameter func_WhyType : forall (a:Type) {a_WT:WhyType a}
  (b:Type) {b_WT:WhyType b}, WhyType (func a b).
Existing Instance func_WhyType.

(* Why3 assumption *)
Definition pred (a:Type) := (a -> bool).

Parameter infix_at: forall {a:Type} {a_WT:WhyType a}
  {b:Type} {b_WT:WhyType b}, (a -> b) -> a -> b.

Parameter sum: int -> int -> (int -> int) -> int.

Axiom sum_def1 : forall (f:(int -> int)) (a:int) (b:int),
  is_true (b < a)%Z -> ((sum a b f) = 0%Z).

Axiom sum_def2 : forall (f:(int -> int)) (a:int) (b:int),
  is_true (a <= b)%Z -> ((sum a b f) = ((sum a (b - 1%Z)%Z f) + (f b))%Z).

Axiom sum_left : forall (f:(int -> int)) (a:int) (b:int),
  is_true (a <= b)%Z -> ((sum a b f) = ((f a) + (sum (a + 1%Z)%Z b f))%Z).

Axiom sum_ext : forall (f:(int -> int)) (g:(int -> int)) (a:int) (b:int),
  (forall (i:int), (is_true (a <= i)%Z /\ is_true (i <= b)%Z) -> ((f i) = (g
  i))) -> ((sum a b f) = (sum a b g)).

Axiom sum_le : forall (f:(int -> int)) (g:(int -> int)) (a:int) (b:int),
  (forall (i:int), (is_true (a <= i)%Z /\ is_true (i <= b)%Z) -> is_true ((f
  i) <= (g i))%Z) -> is_true ((sum a b f) <= (sum a b g))%Z.

Axiom sum_nonneg : forall (f:(int -> int)) (a:int) (b:int), (forall (i:int),
  (is_true (a <= i)%Z /\ is_true (i <= b)%Z) -> is_true (0%Z <= (f i))%Z) ->
  is_true (0%Z <= (sum a b f))%Z.

Axiom sum_decomp : forall (f:(int -> int)) (a:int) (b:int) (c:int),
  (is_true (a <= b)%Z /\ is_true (b <= c)%Z) -> ((sum a c f) = ((sum a b
  f) + (sum (b + 1%Z)%Z c f))%Z).

(* Why3 assumption *)
Definition sum_sub_array (a:(array int)) (lo:int) (hi:int): int := (sum lo hi
  (fun (i:int) => (get1 a i))).

(* Why3 assumption *)
Definition sum_array (a:(array int)): int := (sum_sub_array a 0%Z
  ((length a) - 1%Z)%Z).

Axiom sum_sub_array_shift : forall (a:(array int)) (b:(array int)) (lo:int)
  (hi:int), ((is_true (0%Z <= (length a))%Z /\
  is_true (0%Z <= (length b))%Z) /\ ((((length a) + 1%Z)%Z = (length b)) /\
  forall (i:int), (is_true (lo <= i)%Z /\ is_true (i <= hi)%Z) -> ((get1 a
  i) = (get1 b (i + 1%Z)%Z)))) -> ((sum_sub_array a lo hi) = (sum_sub_array b
  (lo + 1%Z)%Z (hi + 1%Z)%Z)).

Parameter numof: (int -> bool) -> int -> int -> int.

Axiom Numof_empty : forall (p:(int -> bool)) (a:int) (b:int),
  is_true (b <= a)%Z -> ((numof p a b) = 0%Z).

Axiom Numof_right_no_add : forall (p:(int -> bool)) (a:int) (b:int),
  is_true (a < b)%Z -> ((~ ((p (b - 1%Z)%Z) = true)) -> ((numof p a
  b) = (numof p a (b - 1%Z)%Z))).

Axiom Numof_right_add : forall (p:(int -> bool)) (a:int) (b:int),
  is_true (a < b)%Z -> (((p (b - 1%Z)%Z) = true) -> ((numof p a
  b) = (1%Z + (numof p a (b - 1%Z)%Z))%Z)).

Axiom Numof_bounds : forall (p:(int -> bool)) (a:int) (b:int),
  is_true (a < b)%Z -> (is_true (0%Z <= (numof p a b))%Z /\ is_true ((numof p
  a b) <= (b - a)%Z)%Z).

Axiom Numof_append : forall (p:(int -> bool)) (a:int) (b:int) (c:int),
  (is_true (a <= b)%Z /\ is_true (b <= c)%Z) -> ((numof p a c) = ((numof p a
  b) + (numof p b c))%Z).

Axiom Numof_left_no_add : forall (p:(int -> bool)) (a:int) (b:int),
  is_true (a < b)%Z -> ((~ ((p a) = true)) -> ((numof p a b) = (numof p
  (a + 1%Z)%Z b))).

Axiom Numof_left_add : forall (p:(int -> bool)) (a:int) (b:int),
  is_true (a < b)%Z -> (((p a) = true) -> ((numof p a b) = (1%Z + (numof p
  (a + 1%Z)%Z b))%Z)).

Axiom Empty : forall (p:(int -> bool)) (a:int) (b:int), (forall (n:int),
  (is_true (a <= n)%Z /\ is_true (n < b)%Z) -> ~ ((p n) = true)) -> ((numof p
  a b) = 0%Z).

Axiom Full : forall (p:(int -> bool)) (a:int) (b:int), is_true (a <= b)%Z ->
  ((forall (n:int), (is_true (a <= n)%Z /\ is_true (n < b)%Z) -> ((p
  n) = true)) -> ((numof p a b) = (b - a)%Z)).

Axiom numof_increasing : forall (p:(int -> bool)) (i:int) (j:int) (k:int),
  (is_true (i <= j)%Z /\ is_true (j <= k)%Z) -> is_true ((numof p i
  j) <= (numof p i k))%Z.

Axiom numof_strictly_increasing : forall (p:(int -> bool)) (i:int) (j:int)
  (k:int) (l:int), (is_true (i <= j)%Z /\ (is_true (j <= k)%Z /\
  is_true (k < l)%Z)) -> (((p k) = true) -> is_true ((numof p i j) < (numof p
  i l))%Z).

Axiom numof_change_any : forall (p1:(int -> bool)) (p2:(int -> bool)) (a:int)
  (b:int), (forall (j:int), (is_true (a <= j)%Z /\ is_true (j < b)%Z) ->
  (((p1 j) = true) -> ((p2 j) = true))) -> is_true ((numof p1 a
  b) <= (numof p2 a b))%Z.

Axiom numof_change_some : forall (p1:(int -> bool)) (p2:(int -> bool))
  (a:int) (b:int) (i:int), (is_true (a <= i)%Z /\ is_true (i < b)%Z) ->
  ((forall (j:int), (is_true (a <= j)%Z /\ is_true (j < b)%Z) -> (((p1
  j) = true) -> ((p2 j) = true))) -> ((~ ((p1 i) = true)) -> (((p2
  i) = true) -> is_true ((numof p1 a b) < (numof p2 a b))%Z))).

Axiom numof_change_equiv : forall (p1:(int -> bool)) (p2:(int -> bool))
  (a:int) (b:int), (forall (j:int), (is_true (a <= j)%Z /\
  is_true (j < b)%Z) -> (((p1 j) = true) <-> ((p2 j) = true))) -> ((numof p2
  a b) = (numof p1 a b)).

Parameter is_part: (array int) -> bool.

Axiom is_part_def : forall (shape:(array int)), (((forall (i:int) (j:int),
  (is_true (0%Z <= i)%Z /\ (is_true (i <= j)%Z /\
  is_true (j < (length shape))%Z)) -> is_true ((get1 shape j) <= (get1 shape
  i))%Z) /\ is_true (0%Z <= (get1 shape ((length shape) - 1%Z)%Z))%Z) ->
  ((is_part shape) = true)) /\ ((~ ((forall (i:int) (j:int),
  (is_true (0%Z <= i)%Z /\ (is_true (i <= j)%Z /\
  is_true (j < (length shape))%Z)) -> is_true ((get1 shape j) <= (get1 shape
  i))%Z) /\ is_true (0%Z <= (get1 shape ((length shape) - 1%Z)%Z))%Z)) ->
  ((is_part shape) = false)).

Axiom is_part_nonneg : forall (sh:(array int)), ((is_part sh) = true) ->
  forall (i:int), (is_true (0%Z <= i)%Z /\ is_true (i < (length sh))%Z) ->
  is_true (0%Z <= (get1 sh i))%Z.

Parameter included: (array int) -> (array int) -> bool.

Axiom included_def : forall (inner1:(array int)) (outer1:(array int)),
  ((((length inner1) = (length outer1)) /\ forall (i:int),
  (is_true (0%Z <= i)%Z /\ is_true (i < (length outer1))%Z) ->
  is_true ((get1 inner1 i) <= (get1 outer1 i))%Z) -> ((included inner1
  outer1) = true)) /\ ((~ (((length inner1) = (length outer1)) /\
  forall (i:int), (is_true (0%Z <= i)%Z /\
  is_true (i < (length outer1))%Z) -> is_true ((get1 inner1
  i) <= (get1 outer1 i))%Z)) -> ((included inner1 outer1) = false)).

Axiom sum_le_eq : forall (f:(int -> int)) (g:(int -> int)) (a:int) (b:int),
  ((forall (i:int), (is_true (a <= i)%Z /\ is_true (i <= b)%Z) -> is_true ((f
  i) <= (g i))%Z) /\ ((sum a b f) = (sum a b g))) -> forall (i:int),
  (is_true (a <= i)%Z /\ is_true (i <= b)%Z) -> ((f i) = (g i)).

Axiom included_parts_eq : forall (innev:(array int)) (eval:(array int)),
  ((included innev eval) = true) ->
  (((sum_array innev) = (sum_array eval)) -> forall (i:int),
  (is_true (0%Z <= i)%Z /\ is_true (i < (length innev))%Z) -> ((get1 innev
  i) = (get1 eval i))).

Parameter fc: (array int) -> int -> (int -> bool).

Axiom fc_def : forall (a:(array int)) (v:int) (i:int), (((fc a v)
  i) = true) <-> ((get1 a i) = v).

(* Why3 assumption *)
Definition numeq (a:(array int)) (v:int) (lo:int) (hi:int): int :=
  (numof (fc a v) lo hi).

(* Why3 assumption *)
Definition is_yam_prefix (w:(array int)) (len:int): Prop :=
  (is_true (0%Z <= len)%Z /\ is_true (len <= (length w))%Z) /\
  ((forall (i:int), (is_true (0%Z <= i)%Z /\ is_true (i < len)%Z) ->
  is_true (0%Z <= (get1 w i))%Z) /\ forall (p:int), (is_true (0%Z <= p)%Z /\
  is_true (p <= len)%Z) -> forall (v:int), is_true (0%Z <= v)%Z ->
  is_true ((numeq w (v + 1%Z)%Z 0%Z p) <= (numeq w v 0%Z p))%Z).

(* Why3 assumption *)
Definition is_yam_of_eval_prefix (eval:(array int)) (w:(array int))
  (len:int): Prop := (is_yam_prefix w len) /\ ((forall (i:int),
  (is_true (0%Z <= i)%Z /\ is_true (i < len)%Z) -> (is_true (0%Z <= (get1 w
  i))%Z /\ is_true ((get1 w i) < (length eval))%Z)) /\ forall (v:int),
  (is_true (0%Z <= v)%Z /\ is_true (v < (length eval))%Z) -> ((numeq w v 0%Z
  len) = (get1 eval v))).

(* Why3 assumption *)
Definition is_yam_of_eval (eval:(array int)) (w:(array int)): Prop :=
  (is_yam_of_eval_prefix eval w (length w)).

(* Why3 assumption *)
Inductive skew_shape :=
  | mk_skew_shape : (array int) -> (array int) -> (array int) -> (array
      int) -> (array int) -> skew_shape.
Axiom skew_shape_WhyType : WhyType skew_shape.
Existing Instance skew_shape_WhyType.

(* Why3 assumption *)
Definition below (v:skew_shape): (array int) :=
  match v with
  | (mk_skew_shape x x1 x2 x3 x4) => x4
  end.

(* Why3 assumption *)
Definition end_of_overlap (v:skew_shape): (array int) :=
  match v with
  | (mk_skew_shape x x1 x2 x3 x4) => x3
  end.

(* Why3 assumption *)
Definition end_of_row (v:skew_shape): (array int) :=
  match v with
  | (mk_skew_shape x x1 x2 x3 x4) => x2
  end.

(* Why3 assumption *)
Definition inner (v:skew_shape): (array int) :=
  match v with
  | (mk_skew_shape x x1 x2 x3 x4) => x1
  end.

(* Why3 assumption *)
Definition outer (v:skew_shape): (array int) :=
  match v with
  | (mk_skew_shape x x1 x2 x3 x4) => x
  end.

(* Why3 assumption *)
Definition is_tableau_reading_prefix (s:skew_shape) (w:(array int))
  (len:int): Prop := (forall (r:int), (is_true (1%Z <= r)%Z /\
  is_true (r < (length (outer s)))%Z) -> forall (i:int),
  is_true (i < len)%Z -> ((is_true ((get1 (end_of_row s)
  (r - 1%Z)%Z) <= i)%Z /\ is_true (i < ((get1 (end_of_row s)
  r) - 1%Z)%Z)%Z) -> is_true ((get1 w (i + 1%Z)%Z) <= (get1 w i))%Z)) /\
  forall (r:int), (is_true (1%Z <= r)%Z /\
  is_true (r < (length (outer s)))%Z) -> forall (i:int),
  is_true (i < len)%Z -> ((is_true ((get1 (end_of_row s)
  (r - 1%Z)%Z) <= i)%Z /\ is_true (i < (get1 (end_of_overlap s) r))%Z) ->
  is_true ((get1 w (i - (get1 (below s) r))%Z) < (get1 w i))%Z).

(* Why3 assumption *)
Definition is_tableau_reading (s:skew_shape) (w:(array int)): Prop :=
  (is_tableau_reading_prefix s w (length w)).

(* Why3 assumption *)
Definition is_solution_prefix (s:skew_shape) (eval:(array int)) (w:(array
  int)) (len:int): Prop := (is_yam_of_eval_prefix eval w len) /\
  (is_tableau_reading_prefix s w len).

(* Why3 assumption *)
Definition is_solution (s:skew_shape) (eval:(array int)) (w:(array
  int)): Prop := (is_yam_of_eval eval w) /\ (is_tableau_reading s w).

(* Why3 assumption *)
Definition valid_normalized_outer_inner (outer1:(array int)) (inner1:(array
  int)): Prop := (is_true (2%:Z <= (length outer1))%Z /\
  ((length outer1) = (length inner1))) /\ (((included inner1
  outer1) = true) /\ (((is_part inner1) = true) /\
  (((is_part outer1) = true) /\ (((get1 outer1 0%Z) = (get1 inner1 0%Z)) /\
  ((get1 inner1 0%Z) = (get1 outer1 1%Z)))))).

(* Why3 assumption *)
Definition valid_end_of_row (outer1:(array int)) (inner1:(array int))
  (end_of_row1:(array int)): Prop :=
  ((length end_of_row1) = (length outer1)) /\ (((get1 end_of_row1
  0%Z) = 0%Z) /\ forall (i:int), (is_true (1%Z <= i)%Z /\
  is_true (i < (length end_of_row1))%Z) -> ((get1 end_of_row1 i) = (sum 1%Z i
  (fun (j:int) => ((get1 outer1 j) - (get1 inner1 j))%Z)))).

(* Why3 assumption *)
Definition valid_skew_shape (sh:skew_shape): Prop :=
  (valid_normalized_outer_inner (outer sh) (inner sh)) /\ ((valid_end_of_row
  (outer sh) (inner sh) (end_of_row sh)) /\
  ((((length (end_of_overlap sh)) = (length (below sh))) /\
  ((length (below sh)) = (length (outer sh)))) /\ forall (i:int),
  (is_true (1%Z <= i)%Z /\ is_true (i < (length (end_of_overlap sh)))%Z) ->
  (((get1 (below sh) i) = ((get1 (outer sh) i) - (get1 (inner sh)
  (i - 1%Z)%Z))%Z) /\ ((get1 (end_of_overlap sh) i) = ((get1 (end_of_row sh)
  (i - 1%Z)%Z) + (get1 (below sh) i))%Z)))).

