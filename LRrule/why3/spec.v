(* This file is generated by Why3's coq-ssreflect driver *)
(* Beware! Only edit allowed sections below    *)

Require Import ssreflect ssrbool ssrfun ssrnat seq eqtype ssrint.
Require Import ssrint ssrwhy3.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.


Require Import ssralg ssrnum.

Import GRing.Theory Num.Theory.
Local Open Scope ring_scope.

(* Why3 assumption *)
Definition unit := unit.

Axiom qtmark : Type.
Parameter set: forall {a: why3Type} {b: why3Type}, (a -> b)%type -> a -> b ->
  (a -> b)%type.

Axiom Select_eq : forall {a: why3Type} {b: why3Type},
  forall (m:(a -> b)%type), forall (a1:a) (a2:a), forall (b1:b), (a1 = a2) ->
  (((set m a1 b1) a2) = b1).

Axiom Select_neq : forall {a: why3Type} {b: why3Type},
  forall (m:(a -> b)%type), forall (a1:a) (a2:a), forall (b1:b),
  (~ (a1 = a2)) -> (((set m a1 b1) a2) = (m a2)).

Parameter const: forall {a: why3Type} {b: why3Type}, b -> (a -> b)%type.

Parameter sum: int -> int -> (int -> int) -> int.

Axiom sum_def1 : forall (f:(int -> int)) (a:int) (b:int), (b < a)%Z ->
  ((sum a b f) = 0%Z).

Axiom sum_def2 : forall (f:(int -> int)) (a:int) (b:int), (a <= b)%Z ->
  ((sum a b f) = ((sum a (b - 1%Z)%Z f) + (f b))%Z).

Axiom sum_left : forall (f:(int -> int)) (a:int) (b:int), (a <= b)%Z ->
  ((sum a b f) = ((f a) + (sum (a + 1%Z)%Z b f))%Z).

Axiom sum_ext : forall (f:(int -> int)) (g:(int -> int)) (a:int) (b:int),
  (forall (i:int), ((a <= i)%Z /\ (i <= b)%Z) -> ((f i) = (g i))) -> ((sum a
  b f) = (sum a b g)).

Axiom sum_le : forall (f:(int -> int)) (g:(int -> int)) (a:int) (b:int),
  (forall (i:int), ((a <= i)%Z /\ (i <= b)%Z) -> ((f i) <= (g i))%Z) ->
  ((sum a b f) <= (sum a b g))%Z.

Axiom sum_nonneg : forall (f:(int -> int)) (a:int) (b:int), (forall (i:int),
  ((a <= i)%Z /\ (i <= b)%Z) -> (0%Z <= (f i))%Z) -> (0%Z <= (sum a b f))%Z.

Axiom sum_decomp : forall (f:(int -> int)) (a:int) (b:int) (c:int),
  ((a <= b)%Z /\ (b <= c)%Z) -> ((sum a c f) = ((sum a b
  f) + (sum (b + 1%Z)%Z c f))%Z).

(* Why3 assumption *)
Definition sum_sub_array (a:(array int)) (lo:int) (hi:int): int := (sum lo hi
  (fun (i:int) => (get a i))).

(* Why3 assumption *)
Definition sum_array (a:(array int)): int := (sum_sub_array a 0%Z
  ((size a : int) - 1%Z)%Z).

Axiom sum_sub_array_shift : forall (a:(array int)) (b:(array int)) (lo:int)
  (hi:int), (((0%Z <= (size a : int))%Z /\ (0%Z <= (size b : int))%Z) /\
  ((((size a : int) + 1%Z)%Z = (size b : int)) /\ forall (i:int),
  ((lo <= i)%Z /\ (i <= hi)%Z) -> ((get a i) = (get b (i + 1%Z)%Z)))) ->
  ((sum_sub_array a lo hi) = (sum_sub_array b (lo + 1%Z)%Z (hi + 1%Z)%Z)).

Axiom sum_array_sub : forall (a:(array int)) (b:(array int)) (lo:int)
  (hi:int), (((0%Z <= (size a : int))%Z /\ (0%Z <= (size b : int))%Z) /\
  ((size a : int) = (size b : int))) -> ((sum lo hi (fun (i:int) =>
  ((get b i) - (get a i))%Z)) = ((sum_sub_array b lo hi) - (sum_sub_array a
  lo hi))%Z).

Parameter numof: (int -> bool) -> int -> int -> int.

Axiom Numof_empty : forall (p:(int -> bool)) (a:int) (b:int), (b <= a)%Z ->
  ((numof p a b) = 0%Z).

Axiom Numof_right_no_add : forall (p:(int -> bool)) (a:int) (b:int),
  (a < b)%Z -> ((~ ((p (b - 1%Z)%Z) = true)) -> ((numof p a b) = (numof p a
  (b - 1%Z)%Z))).

Axiom Numof_right_add : forall (p:(int -> bool)) (a:int) (b:int),
  (a < b)%Z -> (((p (b - 1%Z)%Z) = true) -> ((numof p a b) = (1%Z + (numof p
  a (b - 1%Z)%Z))%Z)).

Axiom Numof_bounds : forall (p:(int -> bool)) (a:int) (b:int), (a < b)%Z ->
  ((0%Z <= (numof p a b))%Z /\ ((numof p a b) <= (b - a)%Z)%Z).

Axiom Numof_append : forall (p:(int -> bool)) (a:int) (b:int) (c:int),
  ((a <= b)%Z /\ (b <= c)%Z) -> ((numof p a c) = ((numof p a b) + (numof p b
  c))%Z).

Axiom Numof_left_no_add : forall (p:(int -> bool)) (a:int) (b:int),
  (a < b)%Z -> ((~ ((p a) = true)) -> ((numof p a b) = (numof p (a + 1%Z)%Z
  b))).

Axiom Numof_left_add : forall (p:(int -> bool)) (a:int) (b:int), (a < b)%Z ->
  (((p a) = true) -> ((numof p a b) = (1%Z + (numof p (a + 1%Z)%Z b))%Z)).

Axiom Empty : forall (p:(int -> bool)) (a:int) (b:int), (forall (n:int),
  ((a <= n)%Z /\ (n < b)%Z) -> ~ ((p n) = true)) -> ((numof p a b) = 0%Z).

Axiom Full : forall (p:(int -> bool)) (a:int) (b:int), (a <= b)%Z ->
  ((forall (n:int), ((a <= n)%Z /\ (n < b)%Z) -> ((p n) = true)) -> ((numof p
  a b) = (b - a)%Z)).

Axiom numof_increasing : forall (p:(int -> bool)) (i:int) (j:int) (k:int),
  ((i <= j)%Z /\ (j <= k)%Z) -> ((numof p i j) <= (numof p i k))%Z.

Axiom numof_strictly_increasing : forall (p:(int -> bool)) (i:int) (j:int)
  (k:int) (l:int), ((i <= j)%Z /\ ((j <= k)%Z /\ (k < l)%Z)) -> (((p
  k) = true) -> ((numof p i j) < (numof p i l))%Z).

Axiom numof_change_any : forall (p1:(int -> bool)) (p2:(int -> bool)) (a:int)
  (b:int), (forall (j:int), ((a <= j)%Z /\ (j < b)%Z) -> (((p1 j) = true) ->
  ((p2 j) = true))) -> ((numof p1 a b) <= (numof p2 a b))%Z.

Axiom numof_change_some : forall (p1:(int -> bool)) (p2:(int -> bool))
  (a:int) (b:int) (i:int), ((a <= i)%Z /\ (i < b)%Z) -> ((forall (j:int),
  ((a <= j)%Z /\ (j < b)%Z) -> (((p1 j) = true) -> ((p2 j) = true))) ->
  ((~ ((p1 i) = true)) -> (((p2 i) = true) -> ((numof p1 a b) < (numof p2 a
  b))%Z))).

Axiom numof_change_equiv : forall (p1:(int -> bool)) (p2:(int -> bool))
  (a:int) (b:int), (forall (j:int), ((a <= j)%Z /\ (j < b)%Z) -> (((p1
  j) = true) <-> ((p2 j) = true))) -> ((numof p2 a b) = (numof p1 a b)).

(* Why3 assumption *)
Definition is_part (shape:(array int)): Prop :=
  (1%Z <= (size shape : int))%Z /\ ((forall (i:int) (j:int), ((0%Z <= i)%Z /\
  ((i <= j)%Z /\ (j < (size shape : int))%Z)) ->
  ((get shape j) <= (get shape i))%Z) /\
  (0%Z <= (get shape ((size shape : int) - 1%Z)%Z))%Z).

Axiom is_part_nonneg : forall (sh:(array int)), (is_part sh) ->
  forall (i:int), ((0%Z <= i)%Z /\ (i < (size sh : int))%Z) ->
  (0%Z <= (get sh i))%Z.

(* Why3 assumption *)
Definition included (inner1:(array int)) (outer1:(array int)): Prop :=
  ((size inner1 : int) = (size outer1 : int)) /\ forall (i:int),
  ((0%Z <= i)%Z /\ (i < (size outer1 : int))%Z) ->
  ((get inner1 i) <= (get outer1 i))%Z.

Axiom sum_le_eq : forall (f:(int -> int)) (g:(int -> int)) (a:int) (b:int),
  ((forall (i:int), ((a <= i)%Z /\ (i <= b)%Z) -> ((f i) <= (g i))%Z) /\
  ((sum a b f) = (sum a b g))) -> forall (i:int), ((a <= i)%Z /\
  (i <= b)%Z) -> ((f i) = (g i)).

Axiom included_parts_eq : forall (innev:(array int)) (eval:(array int)),
  (included innev eval) -> (((sum_array innev) = (sum_array eval)) ->
  forall (i:int), ((0%Z <= i)%Z /\ (i < (size innev : int))%Z) ->
  ((get innev i) = (get eval i))).

Parameter fc: (array int) -> int -> (int -> bool).

Axiom fc_def : forall (a:(array int)) (v:int) (i:int), (((fc a v)
  i) = true) <-> ((get a i) = v).

(* Why3 assumption *)
Definition numeq (a:(array int)) (v:int) (lo:int) (hi:int): int :=
  (numof (fc a v) lo hi).

(* Why3 assumption *)
Definition is_yam_prefix (w:(array int)) (len:int): Prop :=
  ((0%Z <= len)%Z /\ (len <= (size w : int))%Z) /\ ((forall (i:int),
  ((0%Z <= i)%Z /\ (i < len)%Z) -> (0%Z <= (get w i))%Z) /\ forall (p:int),
  ((0%Z <= p)%Z /\ (p <= len)%Z) -> forall (v1:int) (v2:int),
  ((0%Z <= v1)%Z /\ (v1 <= v2)%Z) -> ((numeq w v2 0%Z p) <= (numeq w v1 0%Z
  p))%Z).

(* Why3 assumption *)
Definition is_yam_of_eval_prefix (eval:(array int)) (w:(array int))
  (len:int): Prop := (is_yam_prefix w len) /\ ((forall (i:int),
  ((0%Z <= i)%Z /\ (i < len)%Z) -> ((0%Z <= (get w i))%Z /\
  ((get w i) < (size eval : int))%Z)) /\ forall (v:int), ((0%Z <= v)%Z /\
  (v < (size eval : int))%Z) -> ((numeq w v 0%Z len) = (get eval v))).

(* Why3 assumption *)
Definition is_yam_of_eval (eval:(array int)) (w:(array int)): Prop :=
  (is_yam_of_eval_prefix eval w (size w : int)).

Axiom is_yam_of_eval_length : forall (eval:(array int)) (w:(array int)),
  (is_yam_of_eval eval w) -> ((size w : int) = (sum_array eval)).

(* Why3 assumption *)
Inductive skew_shape :=
  | mk_skew_shape : (array int) -> (array int) -> (array int) ->
      (array int) -> (array int) -> skew_shape.

(* Why3 assumption *)
Definition below (v:skew_shape): (array int) :=
  match v with
  | (mk_skew_shape x x1 x2 x3 x4) => x4
  end.

(* Why3 assumption *)
Definition end_of_overlap (v:skew_shape): (array int) :=
  match v with
  | (mk_skew_shape x x1 x2 x3 x4) => x3
  end.

(* Why3 assumption *)
Definition end_of_row (v:skew_shape): (array int) :=
  match v with
  | (mk_skew_shape x x1 x2 x3 x4) => x2
  end.

(* Why3 assumption *)
Definition inner (v:skew_shape): (array int) :=
  match v with
  | (mk_skew_shape x x1 x2 x3 x4) => x1
  end.

(* Why3 assumption *)
Definition outer (v:skew_shape): (array int) :=
  match v with
  | (mk_skew_shape x x1 x2 x3 x4) => x
  end.

(* Why3 assumption *)
Definition is_tableau_reading_prefix (s:skew_shape) (w:(array int))
  (len:int): Prop := (forall (r:int), ((1%Z <= r)%Z /\
  (r < (size (outer s) : int))%Z) -> forall (i:int), (i < len)%Z ->
  ((((get (end_of_row s) (r - 1%Z)%Z) <= i)%Z /\
  (i < ((get (end_of_row s) r) - 1%Z)%Z)%Z) ->
  ((get w (i + 1%Z)%Z) <= (get w i))%Z)) /\ forall (r:int), ((1%Z <= r)%Z /\
  (r < (size (outer s) : int))%Z) -> forall (i:int), (i < len)%Z ->
  ((((get (end_of_row s) (r - 1%Z)%Z) <= i)%Z /\
  (i < (get (end_of_overlap s) r))%Z) ->
  ((get w (i - (get (below s) r))%Z) < (get w i))%Z).

(* Why3 assumption *)
Definition is_tableau_reading (s:skew_shape) (w:(array int)): Prop :=
  (is_tableau_reading_prefix s w (size w : int)).

(* Why3 assumption *)
Definition is_solution_prefix (s:skew_shape) (eval:(array int))
  (w:(array int)) (len:int): Prop := (is_yam_of_eval_prefix eval w len) /\
  (is_tableau_reading_prefix s w len).

(* Why3 assumption *)
Definition is_solution (s:skew_shape) (eval:(array int))
  (w:(array int)): Prop := (is_yam_of_eval eval w) /\ (is_tableau_reading s
  w).

(* Why3 assumption *)
Definition valid_normalized_outer_inner (outer1:(array int))
  (inner1:(array int)): Prop := ((2%:Z <= (size outer1 : int))%Z /\
  ((size outer1 : int) = (size inner1 : int))) /\ ((included inner1
  outer1) /\ ((is_part inner1) /\ ((is_part outer1) /\
  (((get outer1 0%Z) = (get inner1 0%Z)) /\
  ((get inner1 0%Z) = (get outer1 1%Z)))))).

(* Why3 assumption *)
Definition valid_end_of_row (outer1:(array int)) (inner1:(array int))
  (end_of_row1:(array int)): Prop :=
  ((size end_of_row1 : int) = (size outer1 : int)) /\
  (((get end_of_row1 0%Z) = 0%Z) /\ forall (i:int), ((1%Z <= i)%Z /\
  (i < (size end_of_row1 : int))%Z) -> ((get end_of_row1 i) = (sum 1%Z i
  (fun (j:int) => ((get outer1 j) - (get inner1 j))%Z)))).

(* Why3 assumption *)
Definition valid_skew_shape (sh:skew_shape): Prop :=
  (valid_normalized_outer_inner (outer sh) (inner sh)) /\ ((valid_end_of_row
  (outer sh) (inner sh) (end_of_row sh)) /\
  ((((size (end_of_overlap sh) : int) = (size (below sh) : int)) /\
  ((size (below sh) : int) = (size (outer sh) : int))) /\ forall (i:int),
  ((1%Z <= i)%Z /\ (i < (size (end_of_overlap sh) : int))%Z) ->
  (((get (below sh) i) = ((get (outer sh) i) - (get (inner sh) (i - 1%Z)%Z))%Z) /\
  ((get (end_of_overlap sh) i) = ((get (end_of_row sh) (i - 1%Z)%Z) + (get (below sh) i))%Z)))).

Axiom end_of_row_last : forall (sh:skew_shape), (valid_skew_shape sh) ->
  ((get (end_of_row sh) ((size (end_of_row sh) : int) - 1%Z)%Z) = ((sum_array (outer sh)) - (sum_array (inner sh)))%Z).

Axiom solution_length : forall (s:skew_shape) (eval:(array int))
  (w:(array int)), (valid_skew_shape s) -> ((is_solution s eval w) ->
  ((size w : int) = (sum_array eval))).

(* Why3 assumption *)
Definition eq_prefix (s1:(array int)) (s2:(array int)) (i:int): Prop :=
  forall (k:int), ((0%Z <= k)%Z /\ (k < i)%Z) -> ((get s1 k) = (get s2 k)).

(* Why3 assumption *)
Definition lt_sol (s1:(array int)) (s2:(array int)): Prop :=
  ((size s1 : int) = (size s2 : int)) /\ exists i:int, ((0%Z <= i)%Z /\
  (i < (size s1 : int))%Z) /\ ((eq_prefix s1 s2 i) /\
  ((get s1 i) < (get s2 i))%Z).

(* Why3 assumption *)
Definition eq_sol (s1:(array int)) (s2:(array int)): Prop :=
  ((size s1 : int) = (size s2 : int)) /\ (eq_prefix s1 s2 (size s1 : int)).

Axiom lt_not_eq : forall (s1:(array int)) (s2:(array int)), (lt_sol s1 s2) ->
  ~ (eq_sol s1 s2).

Axiom solution : Type.
Parameter a2s: (array int) -> solution.

Parameter s2a: solution -> (array int).

Axiom a2s2a_def : forall (a:(array int)), ((s2a (a2s a)) = a).

(* Why3 assumption *)
Inductive solutions :=
  | mk_solutions : (int -> solution)%type -> int -> solutions.

(* Why3 assumption *)
Definition next (v:solutions): int :=
  match v with
  | (mk_solutions x x1) => x1
  end.

(* Why3 assumption *)
Definition sols (v:solutions): (int -> solution)%type :=
  match v with
  | (mk_solutions x x1) => x
  end.

(* Why3 assumption *)
Definition sorted (s:solutions) (lo:int) (hi:int): Prop := forall (i:int)
  (j:int), ((lo <= i)%Z /\ ((i < j)%Z /\ (j < hi)%Z)) -> (lt_sol
  (s2a ((sols s) i)) (s2a ((sols s) j))).

Axiom no_duplicate : forall (s:solutions) (lo:int) (hi:int), (sorted s lo
  hi) -> forall (i:int) (j:int), ((lo <= i)%Z /\ ((i < j)%Z /\
  (j < hi)%Z)) -> ~ (eq_sol (s2a ((sols s) i)) (s2a ((sols s) j))).

(* Why3 assumption *)
Definition good_solutions (sh:skew_shape) (eval:(array int))
  (s:solutions): Prop := (0%Z <= (next s))%Z /\ ((sorted s 0%Z (next s)) /\
  ((forall (i:int), ((0%Z <= i)%Z /\ (i < (next s))%Z) -> (is_solution sh
  eval (s2a ((sols s) i)))) /\ forall (w:(array int)), (is_solution sh eval
  w) -> exists i:int, ((0%Z <= i)%Z /\ (i < (next s))%Z) /\ (eq_sol w
  (s2a ((sols s) i))))).

(* Why3 assumption *)
Definition valid_eval (eval:(array int)): Prop :=
  (1%Z <= (size eval : int))%Z /\ ((is_part eval) /\
  ((get eval ((size eval : int) - 1%Z)%Z) = 0%Z)).

(* Why3 assumption *)
Definition valid_innev (eval:(array int)) (innev:(array int))
  (work:(array int)) (idx:int) (lastinnev:int): Prop :=
  ((size eval : int) = (size innev : int)) /\ (((0%Z <= lastinnev)%Z /\
  (lastinnev < (size eval : int))%Z) /\ ((is_part innev) /\ ((included innev
  eval) /\ ((forall (i:int), ((0%Z <= i)%Z /\ (i < idx)%Z) ->
  ((0%Z <= (get work i))%Z /\ ((get work i) < lastinnev)%Z)) /\
  (((lastinnev = 0%Z) \/ (0%Z < (get innev (lastinnev - 1%Z)%Z))%Z) /\
  forall (i:int), ((lastinnev <= i)%Z /\ (i < (size innev : int))%Z) ->
  ((get innev i) = 0%Z)))))).

Axiom end_of_row_nondecreasing : forall (sh:skew_shape), (valid_skew_shape
  sh) -> forall (i:int), ((0%Z < i)%Z /\
  (i < (size (end_of_row sh) : int))%Z) ->
  ((get (end_of_row sh) (i - 1%Z)%Z) <= (get (end_of_row sh) i))%Z.

Axiom is_part_eq : forall (a1:(array int)) (a2:(array int)), (is_part a1) ->
  ((eq_sol a1 a2) -> (is_part a2)).

