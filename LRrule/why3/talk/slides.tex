\documentclass{beamer}

\usepackage[utf8]{inputenc}

\usetheme{Pittsburgh}
\usecolortheme{beaver}
\definecolor{thered}{rgb}{0.797,0,0}
\definecolor{thegray}{rgb}{0.949,0.949,0.949}
\definecolor{darkgray}{rgb}{0.8477,0.8477,0.8477}
\setbeamercolor{block title}{use=structure,fg=white,bg=red!75!black}
\setbeamercolor{block body}{use=structure,fg=black,bg=darkgray}
\setbeamercolor{item projected}{bg=red}
\setbeamertemplate{enumerate items}[default]

\usepackage[vcentermath]{genyoungtabtikz}
\usepackage{minted}
\usemintedstyle{emacs}

\usepackage{genyoungtabtikz}

\usepackage{commath}
\usepackage{listings,coqlang,ocamllang,why3lang}

\beamertemplatenavigationsymbolsempty
\setbeamertemplate{enumerate items}[ball]
\setbeamercolor{itemize item}{fg=thered}
\setbeamercolor{itemize subitem}{fg=thered}
\setbeamercolor{itemize subsubitem}{fg=thered}
\setbeamercolor{description item}{fg=thered}
\setbeamertemplate{frametitle}{\vspace*{0.5em}\hfill\insertframetitle}
\let\emph\alert

% INFO DOCUMENT - TITRE, AUTEUR, INSTITUTION
\title{\bf\LARGE Computing the
Littlewood-Richardson coefficients\\[5mm]}
\author{Jean-Christophe Filliâtre and Florent Hivert}
\institute{LRI / Université Paris Sud / CNRS}
\date{IFIP WG 1.9/2.15, July 2015}

\newcommand{\XX}{{\mathbb X}}
\newcommand{\free}[1]{\left\langle#1\right\rangle}
\newcommand{\N}{{\mathbb N}}
\newcommand{\C}{{\mathbb C}}
\newcommand{\Q}{{\mathbb Q}}
\newcommand{\SG}{{\mathfrak S}}
\newcommand{\std}{\operatorname{Std}}
\newcommand{\sym}{\mathrm{sym}}
\newcommand{\NCSF}{\mathbf{NCSF}}
\newcommand{\QSym}{\mathrm{QSym}}
\newcommand{\FSym}{\mathbf{FSym}}
\newcommand{\partof}{\vdash}                    % Partition de
\newcommand{\compof}{\vDash}                    % Composisition de
\newcommand{\qandq}{\text{\quad and\quad}}
\newcommand{\alphX}{{\mathbb X}}

\newtheorem{DEFN}{Definition}
\newtheorem{PROP}{Proposition}
\newtheorem{THEO}{Theorem}

%------------------------------------------------------------------------------
\begin{document}

% PAGE D'ACCUEIL
\frame{\titlepage}

\begin{frame}{outline}
  \begin{enumerate}
  \item what are Littlewood-Richardson coefficients
  \item how do we compute them: the Littlewood-Richardson rule
  \item a Coq proof of the rule \par
    (previous work by Florent Hivert)
  \item an efficient program and its proof
  \end{enumerate}
\end{frame}

\begin{frame}{symmetric polynomials}

  $n$-variables : $\XX_n := \{x_0, x_1, \dots x_{n-1}\}$.

  Polynomials in $\XX$ : $P(\XX) = P(x_0, x_1, \dots, x_{n-1})$; ex: $3x_0^3x_2
  + 5 x_1x_2^4$.

  \begin{DEFN}[Symmetric polynomial]
    A polynomial is \emph{symmetric} if it is invariant under any permutation of the
    variables: for all $\sigma\in\SG_n$,
    \[P(x_0, x_1, \dots, x_{n-1}) =
    P(x_{\sigma(0)}, x_{\sigma(1)}, \dots, x_{\sigma({n-1})})\]
  \end{DEFN}

  \[P(a,b,c) = a^2b + a^2c + b^2c + ab^2 + ac^2 + bc^2\]
  \[Q(a,b,c) = 5abc + 3a^2bc + 3ab^2c + 3abc^2\]

\end{frame}

\begin{frame}[fragile]{integer partitions}

  different ways of decomposing an integer $n\in\N$ as a sum:
  \[ 5=5=4+1=3+2=3+1+1=2+2+1=2+1+1+1=1+1+1+1+1 \]

  \begin{DEFN}
    A partition of $n$ is a non-increasing sequence
    $\lambda := (\lambda_0\geq\lambda_1\geq\dots\geq\lambda_{l-1} > 0)$
    such that
    $n = \lambda_0+\lambda_1+\dots+\lambda_{l-1}$.
    We pose $\ell(\lambda) := l.$
  \end{DEFN}

  \bigskip
  Young diagram of a partition: $$(5,3,2,2) \quad\leftrightarrow\quad
  \yngs(1, 2,2,3,5)$$
\end{frame}

\begin{frame}{Schur symmetric polynomials}

  \begin{DEFN}[Schur symmetric polynomial]
    \small Partition $\lambda := (\lambda_0\geq\lambda_1\geq\dots\geq\lambda_{l-1})$ with $l\leq
    n$; set $\lambda_i:=0$ for $i\geq l$.\\

    \[
    s_{\lambda} =
    \frac{\sum_{\sigma\in\SG_n} \operatorname{sign}(\sigma)
      \XX_n^{\sigma(\lambda+\rho)}}%
    {\prod_{0\leq i<j<n} (x_j - x_i)}
    = \frac{\left|
       \begin{smallmatrix}
         x_1^{\lambda_{n-1}+0}  & x_2^{\lambda_{n-1}+0}   & \dots  & x_n^{\lambda_{n-1}+0}  \\
         x_1^{\lambda_{n-2}+1}  & x_2^{\lambda_{n-2}+1}   & \dots  & x_n^{\lambda_{n-2}+1}  \\
         \vdots & \vdots & \ddots & \vdots \\
         x_1^{\lambda_1+n-2}  & x_2^{\lambda_1+n-2}   & \dots  & x_n^{\lambda_1+n-2}  \\
         x_1^{\lambda_0+n-1}  & x_2^{\lambda_0+n-1}   & \dots  & x_n^{\lambda_0+n-1}  \\
      \end{smallmatrix}
      \right|
    }{\left|
       \begin{smallmatrix}
         1      & 1      & \dots  & 1     \\
         x_1    & x_2    & \dots  & x_n    \\
         x_1^2  & x_2^2   & \dots  & x_n^2  \\
         \vdots & \vdots & \ddots & \vdots \\
         x_1^{n-1}  & x_2^{n-1}   & \dots  & x_n^{n-1}  \\
      \end{smallmatrix}
      \right|
    }
    \]
  \end{DEFN}
  \[s_{(2,1)}(a,b,c) = a^2b + ab^2 + a^2c + 2abc + b^2c + ac^2 + bc^2\]
\end{frame}


\begin{frame}{Littlewood-Richardson coefficients}

  \begin{PROP}
    The family $(s_\lambda(\XX_n))_{\ell(\lambda) \leq n}$ is a (linear) basis of the
    ring of symmetric polynomials on $\XX_n$.
  \end{PROP}

  \begin{DEFN}[Littlewood-Richardson coefficients]
    Coefficients $c_{\lambda,\mu}^\nu$ of the expansion of the product:
    \[
    s_\lambda s_\mu = \sum_{\nu} c_{\lambda,\mu}^\nu s_\nu\,.
    \]
  \end{DEFN}

  \bigskip
  Fact: $c_{\lambda,\mu}^\nu$ are independent of the number of variables.
\end{frame}

\begin{frame}
  \begin{center}
    \emph{how to compute the Littlewood-Richardson coefficients} \\
    \hrulefill
  \end{center}
\end{frame}


\Yboxdim{10pt}
\begin{frame}{skew shapes}

  \begin{DEFN}[Skew shape]
    A skew shape $\nu/\lambda$ is a pair of partitions such that the
    Young diagram of $\nu$ contains the Young diagram of $\lambda$.
  \end{DEFN}

  \bigskip
  example:
  $$(5,4,3,2)/(3,3,1)=\gyoung(;;,:;;,:::;,:::;;)$$
\end{frame}

\begin{frame}\frametitle{tableaux}
  \begin{DEFN}[Skew semistandard Young tableau]
    A skew shape $\nu/\lambda$ filled with integers
    \begin{itemize}
    \item non decreasing along the rows
    \item strictly increasing along the columns
    \end{itemize}
  \end{DEFN}

  \bigskip
  example:
  $$\gyoung(02,:;01,:::;1,:::;00)$$
\end{frame}

\begin{frame}\frametitle{row reading}
  \begin{DEFN}[row reading of a tableau]
    the word obtained by concatenating the rows of a skew tableau,
    from top to bottom
  \end{DEFN}
  \bigskip
  example:
  $$\gyoung(02,:;01,:::;1,:::;00) = 0201100$$
\end{frame}

\begin{frame}{Yamanouchi words}

  notation: $\abs{w}_x$ = number of occurrence of $x$ in $w$.

  \bigskip
  \begin{DEFN}[Yamanouchi word]
    A word $w_0,\dots,w_{l-1}$ of integers such that for all $k, i$,
    \[ \abs{w_i,\dots,w_{l-1}}_k \geq \abs{w_i,\dots,w_{l-1}}_{k+1} \]

    Consequence: the evaluation $(\abs{w}_i)_{i\leq\max(w)}$ is a partition.
  \end{DEFN}

  \[ \epsilon, 0, 00, 10, 000, 100, 010, 210, \]
  \[ 0000, 1010, 1100, 0010, 0100, 1000, 0210, 2010, 2100, 3210, etc. \]
\end{frame}

\section{The rule}

\begin{frame}{the rule}

  \begin{THEO}[Littlewood-Richardson rule]
    $c_{\lambda, \mu}^{\nu}$ is the number of skew semistandard
    tableaux of shape $\nu/\lambda$, whose row reading
    is a Yamanouchi word of evaluation $\mu$.
  \end{THEO}
% ...00 ...00 ...00
% ...1  ...1  ...1
% .00   .01   .02
% 12    02    01
  \[
  C_{331,421}^{5432} = 3
  \qquad \Yboxdim{7pt}\tiny
  \gyoung(12,:;00,:::;1,:::;00)\qquad
  \gyoung(02,:;01,:::;1,:::;00)\qquad
  \gyoung(01,:;02,:::;1,:::;00)
  \]
% ...00 ...00 ...00 ...00 ...00 ...00 ...00 ...00 ...00 ...00 ...00 ...00 ...00 ...00 ...00
% ...1  ...1  ...1  ...1  ...1  ...1  ...1  ...1  ...1  ...1  ...1  ...1  ...1  ...1  ...1
% .00   .00   .00   .01   .00   .01   .02   .02   .12   .02   .02   .01   .01   .12   .12
% 01    02    11    01    12    02    01    13    03    03    11    12    22    02    23
  \[
  C_{431,4321}^{7542} = 4
  \qquad \Yboxdim{7pt}\tiny
  \gyoung(23,:;112,:::;01,::::;000)\quad
  \gyoung(23,:;012,:::;11,::::;000)\quad
  \gyoung(13,:;022,:::;11,::::;000)\quad
  \gyoung(03,:;122,:::;11,::::;000)\quad
  \]
  \[
  C_{4321,431}^{7542} = 4
  \qquad \Yboxdim{7pt}\tiny
  \gyoung(:;2,::;11,:::;01,::::;000)\quad
  \gyoung(:;1,::;12,:::;01,::::;000)\quad
  \gyoung(:;1,::;02,:::;11,::::;000)\quad
  \gyoung(:;0,::;12,:::;11,::::;000)\quad
  \]

  \bigskip
  for a proof, see Lascoux, Leclerc, and Thibon, \textit{The Plactic monoid},
    in M.~Lothaire, Algebraic combinatorics on words, CUP.
\end{frame}

\begin{frame}{history}
  \begin{itemize}
  \item stated (1934) by D. E. Littlewood and A. R. Richardson, wrong proof,
    wrong example
  \item Robinson (1938), wrong completed proof
  \item First correct proof: Schützenberger (1977)
  \item Dozens of theses and papers about this proof (Zelevinsky 1981, Macdonald
    1995, Gasharov 1998, Duchamp-H-Thibon 2001, van Leeuwen 2001, Stembridge
    2002)
  \end{itemize}

  \begin{quotation}\small
    \textbf{Wikipedia}: The Littlewood–Richardson rule is notorious for the
    number of errors that appeared prior to its complete, published
    proof. Several published attempts to prove it are incomplete, and it is
    particularly difficult to avoid errors when doing hand calculations with
    it: even the original example in D. E. Littlewood and A. R. Richardson
    (1934) contains an error.
 \end{quotation}
\end{frame}

% $\#P$-hard problem

\begin{frame}{applications}
  \begin{itemize}
  \item multiplicity of induction or restriction of irreducible representations
    of the symmetric groups
  \item multiplicity of the tensor product of the irreducible representations
    of linear groups
  \item geometry: mumber of intersection in a grassmanian variety, cup product
    of the cohomology
  \item Horn problem: eigenvalues of the sum of two Hermitian matrices
  \item extension of Abelian groups (Hall algebra)
  \item application in quantum physics (spectrum rays of the Hydrogen atoms)
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{center}
    \emph{a Coq proof of the Littlewood–Richardson rule} \\
    \hrulefill
  \end{center}
\end{frame}

\begin{frame}\frametitle{a Coq proof of the Littlewood–Richardson rule}
  \begin{itemize}
  \item author: Florent Hivert
  \item uses the Ssreflect extension of Coq \par
    and the Mathematical Components libraries
  \item 15,000 lines of script
  \item available at \url{https://github.com/hivert/Coq-Combi}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{outline of the proof}
  first introduce Schur functions and coefficients $c_{\lambda, \mu}^{\nu}$
\begin{coq}
Schur P1 * Schur P2 =
  \sum_P (Schur P) *+ LRtab_coeff P1 P2 P
\end{coq}
  then introduce tableaux, Yamanouchi words, and define
\begin{coq}
Definition LRyam_set P1 P2 P :=
  [ set y : yameval_finType P2 |
    is_skew_reshape_tableau P P1 y].
Definition LRyam_coeff P1 P2 P :=
  #|LRyam_set P1 P2 P|.
\end{coq}
  finally, prove
\begin{coq}
Theorem LR_coeff_yamP:
  forall P1 P2 P, included P1 P ->
  LRtab_coeff P1 P2 P = LRyam_coeff P1 P2 P.
\end{coq}
\end{frame}

\begin{frame}[fragile]\frametitle{an implementation}
  the Coq proof also includes an \emph{implementation},
  i.e. a function that uses backtracking to compute the coefficients
\begin{coq}
LRcoeff: seq nat -> seq nat -> seq nat -> nat
\end{coq}

\bigskip
it comes with a proof of correctness
\begin{coq}
Theorem LR_yamtabE:
  forall P1 P2 P, included P1 P ->
  LRyam_coeff P1 P2 P = LRcoeff P1 P2 P.
\end{coq}
\end{frame}

\begin{frame}[fragile]\frametitle{an OCaml program}
using Coq extraction mechanism, we get an OCaml code
\begin{ocaml}
type nat = O | S of nat
...
val lRcoeff: nat list -> nat list -> nat list -> nat
\end{ocaml}

\bigskip
with glue code to parse the command line, we can play with it
\begin{verbatim}
./lrcoeff 11 10 9 8 7 6 5 4 3 2 1 - 7 6 5 5 4 3 2 1 -
          7 6 5 5 4 3 2 1
268484
\end{verbatim}
\end{frame}

\begin{frame}\frametitle{efficiency}
  this program is rather inefficient

  (2 orders of magnitude slower than the C library \texttt{lrcalc})

  \bigskip
  because
  \begin{itemize}
  \item it uses \emph{unary Peano numbers} for
    \begin{itemize}
    \item partitions
    \item tableaux indices
    \item tableaux values
    \item solution count
    \end{itemize}
  \item it uses \emph{linear time} \texttt{nth}/\texttt{upd} functions on lists
    everywhere
  \end{itemize}

  \bigskip
  in particular, the OCaml GC is heavily solicited
\end{frame}

\begin{frame}
  \begin{center}
    \emph{an efficient program and its proof} \\
    \hrulefill
  \end{center}
\end{frame}

\begin{frame}\frametitle{goal}
  an efficient OCaml implementation using
  \begin{itemize}
  \item arrays instead of lists
  \item efficient arithmetic instead of type \texttt{nat}
    \begin{itemize}
    \item either arbitrary-precision arithmetic with GMP
    \item or even better machine arithmetic
    \end{itemize}
  \end{itemize}

  \bigskip\bigskip
  we use Why3 and its OCaml extraction mechanism
\end{frame}

\begin{frame}\frametitle{data structures}
  four arrays
  \begin{displaymath}
    \begin{array}{lll}
      \mathtt{outer}~(\nu) & \gyoung(;7;5;4;2)    & \\
      \mathtt{inner}~(\lambda) & \gyoung(;4;3;1;0) & \quad\mbox{(same
        length as \texttt{outer})}\\
      \mathtt{eval}~(\mu) & \gyoung(;4;3;2;1;0) & \quad\mbox{(ends with
        a 0 sentinel)} \\
      \mathtt{innev} & \gyoung(;3;1;0;0;0) &
    \end{array}
  \end{displaymath}
  a matrix for the tableau under construction
  \begin{displaymath}
    \mathtt{work} \qquad\quad \gyoung(;;,:;;;,:::;;1,::::;0;0;0)
    \qquad\qquad\qquad\qquad\qquad
  \end{displaymath}
\end{frame}

\begin{frame}\frametitle{backtracking algorithm}
  \begin{flushleft}
    \texttt{count}(\texttt{row}, \texttt{idx}) = \\
    \quad \emph{if} $\texttt{row}=\mathtt{length}(\mathtt{outer})$ \emph{then
    return} 1 \quad {\small// found one solution} \\
    \quad \emph{if} $\mathtt{idx}<0$ \emph{then return}
    $\mathtt{count}(\mathtt{row}+1,...)$ \quad {\small// move to next row} \\
    \quad $s \leftarrow 0$ \\
    \quad \emph{for} $v$ \emph{in} the range of possible values for
    $\mathtt{work}[\mathtt{row},\mathtt{idx}]$ \\
    \quad \quad $\mathtt{work}[\mathtt{row},\mathtt{idx}] \leftarrow
    v$ \\
    \quad \quad $\texttt{innev}[v] \leftarrow \mathtt{innev}[v]+1$ \\
    \quad \quad $s \leftarrow s + \mathtt{count}(\mathtt{row},
    \mathtt{idx}-1)$ \quad {\small// move to next cell} \\
    \quad \quad $\texttt{innev}[v] \leftarrow \mathtt{innev}[v]-1$ \\
    \quad \emph{return} $s$
  \end{flushleft}
  \begin{displaymath}
    \begin{array}{rc}
       & \mathtt{idx} \\
       & \downarrow \\
      \mathtt{row}\to & \raisebox{1ex}{\gyoung(;;,:;;;,:::;;1,::::;0;0;0)}
    \end{array}
  \end{displaymath}
\end{frame}

\begin{frame}\frametitle{proof}
  we prove
  \begin{itemize}
  \item termination
  \item absence of array access out of bounds
  \item absence of arithmetic overflow
  \item correctness: computes the Littlewood–Richardson coefficient
  \end{itemize}
\end{frame}

\begin{frame}\frametitle{proof: termination}
  immediate: as we make progress in the tableau, the quantity
  \begin{displaymath}
    (\mathtt{length}(\mathtt{outer}) - \mathtt{row}, ~ \mathtt{idx})
  \end{displaymath}
  decreases lexicographically
\end{frame}

\begin{frame}\frametitle{proof: absence of array access out of bounds}
  not very difficult, but requires
  \begin{itemize}
  \item the 0 sentinel in \texttt{eval} \par
  \item some invariants \par (e.g. values in \texttt{work} are smaller than
    $\mathtt{length}(\mathtt{eval})$)
  \item some frame properties
  \end{itemize}
\end{frame}

\begin{frame}\frametitle{proof: absence of arithmetic overflow}
  \begin{itemize}
  \item with arbitrary precision arithmetic \par
    $\Rightarrow$ nothing to do \par
    $\Rightarrow$ but will translate to arbitrary precision arithmetic (GMP)

  \bigskip
  \item with 64-bit machine arithmetic
    \begin{itemize}
    \item array indices and tableaux values indeed fit in 64 bits \par
      (both bounded by some array length, itself a 64-bit
      integer) \par
      $\Rightarrow$ all VCs easily discharged
    \item but what about the value returned (the total count)?
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Peano arithmetic}
  to implement the counter, we use a different, abstract type of
  integers, with limited operations
\begin{why3}
  type peano
  constant zero: peano
  function succ (p:peano) : peano
\end{why3}
  compiled into OCaml's type of 64-bit integers

\vfill
  see:
  Martin Clochard, Jean-Christophe Filli\^atre, Andrei Paskevich.
  \textit{How to avoid proving the absence of integer overflows}.
  VSTTE 2015
\end{frame}

\begin{frame}\frametitle{efficiency}
  \begin{displaymath}
    \begin{array}{ll}
      \nu & = 24,24,22,20,18,18,16,16,15,13,10,8,8,7,5,5,5,3,2,1 \\
      \lambda & = 20,18,18,18,18,16,15,13,13,11,10,8,7,6,5,5,3,2,2,0 \\
      \mu & = 10,8,5,4,3,2,0
    \end{array}
  \end{displaymath}
  \begin{displaymath}
    c_{\lambda, \mu}^{\nu} = 13,911,775
  \end{displaymath}
  \bigskip
  \begin{center}
    \begin{tabular}{|c|c|c|c|}
      \hline
      extracted & \multicolumn{2}{|c|}{extracted from Why3} & C library \\
      \cline{2-3}
      from Coq  &   ZArith  & machine arith & \texttt{lrcalc} \\
      \hline\hline
      31.6      &    26.7   & 1.18 & 0.35 \\
      \hline
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \emph{proof of correctness} \\
    \hrulefill
  \end{center}
\end{frame}

\begin{frame}[fragile]\frametitle{specification 1/3}
\begin{why3}
predicate is_part (a: array int) =
  ... a is a partition ...
\end{why3}
\begin{why3}
predicate valid_input (outer inner: array int) =
  ... inner and outer are partitions ... /\
  ... inner is included in outer ...
\end{why3}
\begin{why3}
predicate valid_eval (eval: array int) =
  ... eval is a partition ... /\
  ... ends with at least a 0 ...
\end{why3}
\end{frame}

\begin{frame}[fragile]\frametitle{specification 2/3}
  ghost code stores solutions within a global (ghost) array \texttt{s}

  \bigskip
  \begin{columns}
  \column{0.7\textwidth}
\begin{why3}
predicate good_solutions s =
  ... s is sorted ... /\
  ... s contains only solutions ... /\
  ... s contains all solutions ...
\end{why3}

  \column{0.3\textwidth}
  \begin{tabular}{|c|l}
  \multicolumn{1}{c}{\texttt{~~~~s~~~~}} \\\cline{1-1}
  \\\cline{1-1}
  \\\cline{1-1}
  $\vdots$ \\\cline{1-1}
  \\\cline{1-1}
  \\\cline{1-1} & \texttt{next}
  \\
  \\
  \end{tabular}
  \end{columns}
\end{frame}

\begin{frame}[fragile]\frametitle{specification 3/3}
\begin{why3}
let lrrule (outer inner eval: array int) : int =
  requires { valid_input outer inner }
  requires { valid_eval eval }
  requires { sum_array eval =
               sum_array outer - sum_array inner }
  requires { s.next = 0 }
  ensures  { result = s.next }
  ensures  { good_solutions outer inner eval s }
\end{why3}
  \bigskip
  note: the proof is \emph{not yet completed}
\end{frame}

  % \bigskip
  % so far we have proved
  % \begin{itemize}
  % \item \texttt{innev} is a partition included in \texttt{eval}
  % \item \texttt{work} only contains values that are non zero in \texttt{innev}
  % \item all frame properties (\texttt{work} unchanged below
  %   \texttt{row}/\texttt{idx}, \texttt{innev} unchanged at all, etc.)
  % \end{itemize}
  % we still have to prove
  % \begin{itemize}
  % \item tableaux found are indeed solutions
  % \item all solutions found and no duplicate
  % \end{itemize}

\begin{frame}
  \begin{center}
    \emph{connection with the Coq proof} \\
    \hrulefill
  \end{center}
\end{frame}

\begin{frame}\frametitle{a legitimate question}
  are the Why3 and Coq programs computing the same thing?

  \begin{center}
    \includegraphics{proof.mps}
  \end{center}

  after all, we have
  \begin{itemize}
  \item distinct data structures (nats/lists vs ints/arrays)
  \item different specifications (partition, tableau, Yamanouchi word)
  \item different algorithms
  \end{itemize}
\end{frame}

\begin{frame}\frametitle{the big picture}

  let us show the equivalence, using Coq

  \begin{center}
    \includegraphics{proof_equiv.mps}
  \end{center}

  all Why3 definitions are translated into Coq, automatically

  (for Why3, Coq is a prover like any other)
\end{frame}

\begin{frame}[fragile]\frametitle{proof of equivalence}

  in Coq, we define two functions \texttt{part} and \texttt{partw} to
  convert partitions from one type to the other

\bigskip
\begin{coq}
  part: array int -> seq nat
\end{coq}
\begin{coq}
  partw: nat -> seq nat -> array int
\end{coq}
(the first argument is the length)
\end{frame}

\begin{frame}\frametitle{proof of equivalence}
  \begin{center}
    \begin{tabular}{ccc}
      \emph{Coq} & & \emph{from Why3} \\[1em]
      \texttt{inner} & &       \texttt{inner} \\[-1em]
      & $\stackrel{\mathtt{partw}}{\longrightarrow}$
      & \\[-0.5em]
      \texttt{outer} & &\texttt{outer} \\
      \texttt{eval} & &       \texttt{eval} \\[-1.5em]
      & $\stackrel{\mathtt{part}}{\longleftarrow}$ & \\[1em]
      \texttt{inputSpec} & & \texttt{valid\_input} \\
                         & & \texttt{valid\_eval} \\
                         & & \texttt{s} \\
      \texttt{LRcoeff}   & & \texttt{good\_solutions}
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}[fragile]\frametitle{proof of equivalence}
\begin{coq}
Theorem Why3Correct:
  forall innerw outerw evalw: array int,
  valid_input outerw innerw ->
  valid_eval evalw ->
  sum_array evalw =
    sum_array outerw - sum_array innerw ->
  forall s, good_solutions innerw outerw evalw s ->
  s.next =
    LRcoeff (part innerw) (part outerw) (part evalw)
\end{coq}
\end{frame}

\begin{frame}[fragile]\frametitle{proof of equivalence}
the other way round
\bigskip
\begin{coq}
Theorem Why3complete:
  forall inner outer eval: seq nat,
  inputSpec inner eval outer ->
  let l = max (1 + size eval)
              (max (size inner) (size outer)) in
  forall s,
  good_solutions (partw l inner)
                 (partw l outer) (partw l eval) s ->
  s.next = LRcoeff inner outer eval
\end{coq}
\end{frame}

\begin{frame}[fragile]\frametitle{what is the TCB?}
  \begin{itemize}
  \item the Coq definitions and statements
  \item the definition of \texttt{partw}
  \end{itemize}
\begin{coq}
Definition partw (l: nat) (p: seq nat) : array int :=
  mkseq (fun i => Posz (nth 0 p i)) l.
\end{coq}

  \bigskip
  in particular, you don't have to read \emph{any} Why3 definition
\end{frame}

\begin{frame}\frametitle{summary}
  we have presented
  \begin{itemize}
  \item an efficient program to compute the Littlewood–Richardson coefficients
  \item its proof of safety, including absence of arithmetic overflows
  \item its proof of correctness (WIP)
  \item its equivalence, at the specification level, with another
    program already proved correct
  \end{itemize}
\end{frame}

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% "latex -synctex=1 -shell-escape"
%%% Local Variables: LaTeX-command
%%% mode: latex
%%% TeX-master: t
%%% End:
