
(*
   Alt-Ergo 0.99.1
   CVC4 1.4
   Z3 4.3.2
   Coq 8.4pl5
*)

theory Sum

  use import int.Int
  use HighOrd

  function sum (a b: int) (f: int -> int) : int
  (** sum of [f n] for [a <= n <= b] *)

  axiom sum_def1:
    forall f: int -> int, a b: int.
    b < a -> sum a b f = 0

  axiom sum_def2:
    forall f: int -> int, a b: int.
    a <= b -> sum a b f = sum a (b - 1) f + f b

  lemma sum_left:
    forall f: int -> int, a b: int.
    a <= b -> sum a b f = f a + sum (a + 1) b f

  lemma sum_ext:
    forall f g: int -> int, a b: int.
    (forall i. a <= i <= b -> f i = g i) ->
    sum a b f = sum a b g

  lemma sum_le:
    forall f g: int -> int, a b: int.
    (forall i. a <= i <= b -> f i <= g i) ->
    sum a b f <= sum a b g

  lemma sum_nonneg:
    forall f: int -> int, a b: int.
    (forall i. a <= i <= b -> 0 <= f i) ->
    0 <= sum a b f

  lemma sum_decomp:
    forall f: int -> int, a b c: int. a <= b <= c ->
    sum a c f = sum a b f + sum (b+1) c f

end

module ArraySum

  use import int.Int
  use import array.Array
  use import Sum

  function sum_sub_array (a: array int) (lo hi: int) : int =
    sum lo hi (\i: int. a[i])

  function sum_array (a: array int) : int =
    sum_sub_array a 0 (length a - 1)

  let rec lemma sum_sub_array_shift (a b: array int) (lo hi: int)
    requires { length a + 1 = length b }
    requires { forall i: int. lo <= i <= hi -> a[i] = b[i+1] }
    ensures  { sum_sub_array a lo hi = sum_sub_array b (lo+1) (hi+1) }
    variant  { hi - lo }
  =
    if lo <= hi then sum_sub_array_shift a b (lo+1) hi

   let rec lemma sum_array_sub (a b: array int) (lo hi: int)
     requires { length a = length b }
     ensures  { sum lo hi (\ i . b[i] - a[i]) =
                sum_sub_array b lo hi - sum_sub_array a lo hi }
     variant  { hi - lo }
   =
    if lo <= hi then sum_array_sub a b (lo+1) hi

end

module Spec

  use import int.Int
  use import map.Map
  use import array.Array
  use import matrix.Matrix
  use import Sum
  use import ArraySum
  use import int.NumOf

  predicate is_part (shape: array int) =
    1 <= length shape /\
    (forall i j: int. 0 <= i <= j < length shape -> shape[i] >= shape[j] ) /\
    (shape[length shape - 1] >= 0)

  lemma is_part_nonneg:
    forall sh. is_part sh -> forall i: int. 0 <= i < length sh -> 0 <= sh[i]

  predicate included (inner: array int) (outer: array int) =
    (length inner = length outer) /\
    (forall i:int. 0 <= i < length outer -> inner[i] <= outer[i])

  let rec lemma sum_le_eq (f g: int -> int) (a b: int)
    requires { forall i. a <= i <= b -> f i <= g i }
    requires { sum a b f = sum a b g }
    ensures  { forall i. a <= i <= b -> f i = g i }
    variant  { b - a }
  = if a < b then sum_le_eq f g (a+1) b

  lemma included_parts_eq:
    forall innev eval.
    included innev eval -> sum_array innev = sum_array eval ->
    forall i. 0 <= i < length innev -> innev[i] = eval[i]

  (** number of i a[i] = v st lo <= i < hi *)
  function numeq (a: array int) (v: int) (lo hi: int) : int =
    numof (\i: int. a[i] = v) lo hi

  predicate valid_input (outer inner: array int) =
    1 <= length outer = length inner /\
    included inner outer /\
    is_part inner /\ is_part outer

(*
  predicate is_yam_prefix (w: array int) (len: int) =
    0 <= len <= length w /\
    (forall i: int. 0 <= i < len -> 0 <= w[i]) /\
    (forall p: int. 0 <= p <= len ->
       (* forall v: int. 0 <= v -> numeq w (v+1) 0 p <= numeq w v 0 p) *)
       forall v1 v2. 0 <= v1 <= v2 -> numeq w v2 0 p <= numeq w v1 0 p)

  predicate is_yam_of_eval_prefix (eval: array int) (w: array int) (len: int) =
    is_yam_prefix w len /\
    (forall i: int. 0 <= i < len -> 0 <= w[i] < length eval) /\
    (forall v: int. 0 <= v < length eval -> numeq w v 0 len = eval[v])

  predicate is_yam_of_eval (eval: array int) (w: array int) =
    is_yam_of_eval_prefix eval w (length w)

  (* TODO: requires commutation of sum and numeq *)
  lemma is_yam_of_eval_length:
    forall eval w.
    is_yam_of_eval eval w -> length w = sum_array eval

  type skew_shape = {
    outer: array int;
    inner: array int;
    end_of_row: array int;
    end_of_overlap: array int;
    below: array int;
  }

  predicate is_tableau_reading_prefix (s: skew_shape) (w: array int) (len: int) =
    (* each row of the tableau is non-decreasing (from left to right) *)
    (forall r: int. 1 <= r < length s.outer ->
       forall i: int. i < len -> s.end_of_row[r-1] <= i < s.end_of_row[r] - 1 ->
         w[i] >= w[i+1]) /\
    (* each column of the tableau is increasing (from bottom up) *)
    (forall r: int. 1 <= r < length s.outer ->
       forall i: int. i < len -> s.end_of_row[r-1] <= i < s.end_of_overlap[r] ->
         w[i] > w[i - s.below[r]])

  predicate is_tableau_reading (s: skew_shape) (w: array int) =
    is_tableau_reading_prefix s w (length w)

  predicate is_solution_prefix
    (s: skew_shape) (eval: array int) (w: array int) (len: int) =
    is_yam_of_eval_prefix eval w len /\
    is_tableau_reading_prefix s w len

  predicate is_solution (s: skew_shape) (eval: array int) (w: array int) =
    is_yam_of_eval eval w /\
    is_tableau_reading s w

  lemma solution_length:
    forall s eval w. valid_skew_shape s ->
    is_solution s eval w -> length w = sum_array eval

  (** storing solutions we have found so far *)

  (* solutions t and u have the same prefix [0..i[ *)
  predicate eq_prefix (s1 s2: array int) (i: int) =
    forall k: int. 0 <= k < i -> s1[k] = s2[k]

  predicate lt_sol (s1 s2: array int) =
    length s1 = length s2 /\
    exists i: int. 0 <= i < length s1 /\ eq_prefix s1 s2 i /\ s1[i] < s2[i]

  predicate eq_sol (s1 s2: array int) =
    length s1 = length s2 /\
    eq_prefix s1 s2 (length s1)

  lemma lt_not_eq:
    forall s1 s2: array int. lt_sol s1 s2 -> not (eq_sol s1 s2)
*)

  type solution

  function m2s (matrix int) : solution
  function s2m solution : matrix int

  axiom m2s2m_def:
    forall m: matrix int. s2m (m2s m) = m

  type solutions = {
    mutable sols: map int solution;
    mutable next: int; (* next slot for a solution *)
  }

(*
  (* s[lo..hi[ is sorted for lt_sol *)
  predicate sorted (s: solutions) (lo hi: int) =
    forall i j: int. lo <= i < j < hi ->
                     lt_sol (s2a (Map.get s.sols i)) (s2a (Map.get s.sols j))

  (* a sorted array of solutions contains no duplicate *)
  lemma no_duplicate:
    forall s: solutions, lo hi: int. sorted s lo hi ->
    forall i j: int. lo <= i < j < hi ->
      not (eq_sol (s2a (Map.get s.sols i)) (s2a (Map.get s.sols j)))

  predicate good_solutions (sh: skew_shape) (eval: array int) (s: solutions) =
    0 <= s.next /\
    sorted s 0 s.next /\
    (forall i. 0 <= i < s.next ->
      is_solution sh eval (s2a (Map.get s.sols i))) /\
    (forall w. is_solution sh eval w ->
       exists i. 0 <= i < s.next /\ eq_sol w (s2a (Map.get s.sols i)))
*)

  predicate valid_eval (eval: array int) =
    1 <= length eval /\ is_part eval /\
    eval[length eval - 1] = 0 (* sentinel: eval ends with a zero *)

  predicate valid_innev
    (outer inner eval innev: array int)
    (work: matrix int) (row idx lastinnev: int) =
    0 <= lastinnev < length eval /\
    is_part innev /\
    included innev eval /\
    (forall r. 0 <= r < row ->
       forall i. 0 <= i < outer[r] - inner[r] ->
         0 <= Matrix.get work (r, i) < lastinnev) /\
    (row < length outer ->
      forall i. idx < i < outer[row] - inner[row] ->
         0 <= Matrix.get work (row, i) < lastinnev) /\
    (lastinnev = 0 \/ 0 < innev[lastinnev - 1]) /\
    (forall i: int. lastinnev <= i < length innev -> innev[i] = 0)

(*
  lemma is_part_eq:
    forall a1 a2: array int. is_part a1 -> eq_sol a1 a2 -> is_part a2
*)

  predicate frame (outer inner: array int) (w1 w2: matrix int) (row idx: int) =
    (forall r. 0 <= r < row ->
       forall i. 0 <= i < outer[r] - inner[r] ->
         Matrix.get w2 (r, i) = Matrix.get w1 (r, i))
    /\
    (forall i. idx < i < outer[row] - inner[row] ->
         Matrix.get w2 (row, i) = Matrix.get w1 (row, i))

  lemma valid_innev_framed:
    forall outer inner eval innev work1 work2 row idx lastinnev.
    valid_innev outer inner eval innev work1 row idx lastinnev ->
    frame outer inner work1 work2 row idx ->
    valid_innev outer inner eval innev work2 row idx lastinnev

end

module LRrule

  use import int.Int
  use import int.MinMax
  use import ref.Refint
  use import array.Array
  use import matrix.Matrix

  use import Sum
  use import ArraySum
  use import Spec

  val ghost solutions: solutions

  val ghost store_solution (outer inner eval: array int) (w: matrix int)
    : unit
    (* requires { is_solution sh eval w } *)
    writes   { solutions.sols, solutions.next }
    ensures  { solutions.next = (old solutions.next) + 1 }
    ensures  { solutions.sols =
               Map.set (old solutions.sols) (old solutions.next) (m2s w) }

  let compute_width (outer inner: array int) : array int
    requires { length outer = length inner }
    ensures  { length result = length outer }
    ensures  { forall j. 0 <= j < length outer ->
    	       result[j] = outer[j] - inner[j] }
  =
    let n = Array.length outer in
    let width = Array.make n 0 in
    for i = 0 to n - 1 do
      invariant { forall j. 0 <= j < i -> width[j] = outer[j] - inner[j] }
      width[i] <- outer[i] - inner[i]
    done;
    width

  let max_array (a: array int) : int
    ensures  { forall j. 0 <= j < length a -> a[j] <= result }
  =
    let m = ref 0 in
    for i = 0 to Array.length a - 1 do
      invariant { forall j. 0 <= j < i -> a[j] <= !m }
      if a[i] > !m then m := a[i]
    done;
    !m

  let compute_shift (inner: array int) : array int
    ensures  { length result = length inner }
    ensures  { forall j. 0 < j < length inner ->
    	       result[j] = inner[j - 1] - inner[j] }
  =
    let n = Array.length inner in
    let shift = Array.make n 0 in
    for i = 1 to n - 1 do
      invariant { forall j. 0 < j < i -> shift[j] = inner[j-1] - inner[j] }
      shift[i] <- inner[i-1] - inner[i]
    done;
    shift

  (*
     row = current row, in [0 .. length outer[
     idx = current index in row (from left to left),
           in [0 .. outer[row]-inner[row][

   ^  +-------------------+
   |  |_______|___        |
  row |  |________|___    |
   |  |    |__________|___|
   0  |_______|___________|
               0 -> idx -->
  *)

  let lrrule (outer inner eval: array int) : int =
    requires { valid_input outer inner }
    requires { valid_eval eval }
    requires { sum_array eval = sum_array outer - sum_array inner }
    requires { solutions.next = 0 }
    ensures  { result = solutions.next }
    (* ensures  { good_solutions sh eval solutions } *)
    let szshape = Array.length outer in (* = Array.length inner *)
    let width = compute_width outer inner in
    let max_width = max_array width in
    let shift = compute_shift inner in
    let szeval = Array.length eval in
    let innev = Array.make szeval 0 in
    let lastinnev = ref 0 in (* only zeros from this index *)
    let work = Matrix.make szshape max_width 0 in
    let rec count_rec (row idx: int) : int =
      requires { 0 <= row <= szshape }
      requires { if row < szshape then -1 <= idx < width[row] else idx = 0 }
      ensures  { forall i. 0 <= i < length innev -> innev[i] = (old innev)[i] }
      requires { "expl:valid_innev"
                 valid_innev outer inner eval innev work row idx !lastinnev }
      (* requires { is_solution_prefix sh eval work idx } *)
      variant  { szshape - row, idx }
      ensures  { !lastinnev = old !lastinnev }
      ensures  { forall i. 0 <= i < length innev -> innev[i] = (old innev)[i] }
      ensures  { "expl:frame" frame outer inner (old work) work row idx }
      ensures  { result = solutions.next - old solutions.next >= 0 }
      (*
      ensures  { forall i. old solutions.next <= i < solutions.next ->
                 let w = s2a (Map.get solutions.sols i) in
                 is_solution sh eval w /\ eq_prefix (old work) w idx }
      ensures  { forall w. is_solution sh eval w ->
                 eq_prefix (old work) w idx ->
                 exists i. old solutions.next <= i < solutions.next /\
                           eq_sol w (s2a (Map.get solutions.sols i)) }
      ensures  { forall i. 0 <= i < old solutions.next ->
                 Map.get solutions.sols i = Map.get (old solutions.sols) i }
      *)
      if row = szshape then begin
        (* found a solution *)
        ghost store_solution outer inner eval work;
        1 (* found a solution *)
      end else if idx < 0 then
        (* move from row [row-1] to row [row] *)
        count_rec (row + 1)
	  (if row + 1 < szshape then width[row + 1] - 1 else 0)
      else begin
        let min = abstract ensures { result =
          if row > 0 && idx >= shift[row]
          then Matrix.get work (row - 1, idx - shift[row]) + 1 else 0 }
          if row > 0 && idx >= shift[row]
          then Matrix.get work (row - 1, idx - shift[row]) + 1 else 0 end in
        let max = abstract ensures { result =
          if idx = width[row] - 1 then !lastinnev
          else MinMax.min !lastinnev (Matrix.get work (row, idx + 1)) }
          if idx = width[row] - 1 then !lastinnev
          else MinMax.min !lastinnev (Matrix.get work (row, idx + 1)) end in
        let sum = ref 0 in
        'Init:
        for v = min to max do
          invariant { !lastinnev = at !lastinnev 'Init }
          invariant { forall i. 0 <= i < length innev ->
                      innev[i] = (at innev 'Init)[i] }
          invariant { "expl:frame"
                      frame outer inner (at work 'Init) work row idx }
          invariant { "expl:valid_innev"
                  valid_innev outer inner eval innev work row idx !lastinnev }
          invariant { !sum = solutions.next - at solutions.next 'Init >= 0 }
          (*
          invariant { is_tableau_reading_prefix sh work idx }
          invariant { "expl: sorted solutions"
                    sorted solutions (at solutions.next 'Init) solutions.next }
          invariant { "expl: only solutions"
                      forall i. at solutions.next 'Init <= i < solutions.next ->
                      let w = s2a (Map.get solutions.sols i) in
                      is_solution sh eval w /\
                      eq_prefix (at work 'Init) w idx /\
                      min <= w[idx] < v }
          invariant { "expl: all solutions"
                      forall w. is_solution sh eval w ->
                      eq_prefix (at work 'Init) w idx ->
                      min <= w[idx] < v ->
                      exists i. at solutions.next 'Init <= i < solutions.next /\
                                eq_sol w (s2a (Map.get solutions.sols i)) }
          invariant { forall i. 0 <= i < at solutions.next 'Init ->
                Map.get solutions.sols i = Map.get (at solutions.sols 'Init) i }
          *)
          if innev[v] < eval[v] && (v = 0 || innev[v-1] > innev[v]) then begin
            innev[v] <- innev[v] + 1;
            if v = !lastinnev then lastinnev += 1;
            assert { 0 <= v < !lastinnev };
            Matrix.set work (row, idx) v;
            sum += count_rec row (idx - 1);
            innev[v] <- innev[v] - 1;
            (* assert { eq_sol innev (at innev 'L) }; *)
           if !lastinnev = v+1 && innev[v] = 0 then lastinnev -= 1
          end
        done;
        !sum
      end
    in
    count_rec 0 (width[0] - 1)

end

(*
Local Variables:
compile-command: "why3 ide lrrule"
End:
*)
