
(*
   Alt-Ergo 0.99.1
   CVC4 1.4
   Z3 4.3.2
   Coq 8.4pl5
*)

theory Sum

  use import int.Int
  use HighOrd

  function sum (a b: int) (f: int -> int) : int
  (** sum of [f n] for [a <= n <= b] *)

  axiom sum_def1:
    forall f: int -> int, a b: int.
    b < a -> sum a b f = 0

  axiom sum_def2:
    forall f: int -> int, a b: int.
    a <= b -> sum a b f = sum a (b - 1) f + f b

  lemma sum_left:
    forall f: int -> int, a b: int.
    a <= b -> sum a b f = f a + sum (a + 1) b f

  lemma sum_ext:
    forall f g: int -> int, a b: int.
    (forall i. a <= i <= b -> f i = g i) ->
    sum a b f = sum a b g

  lemma sum_le:
    forall f g: int -> int, a b: int.
    (forall i. a <= i <= b -> f i <= g i) ->
    sum a b f <= sum a b g

  lemma sum_nonneg:
    forall f: int -> int, a b: int.
    (forall i. a <= i <= b -> 0 <= f i) ->
    0 <= sum a b f

  lemma sum_decomp:
    forall f: int -> int, a b c: int. a <= b <= c ->
    sum a c f = sum a b f + sum (b+1) c f

end

module ArraySum

  use import int.Int
  use import array.Array
  use import Sum

  function sum_sub_array (a: array int) (lo hi: int) : int =
    sum lo hi (\i: int. a[i])

  function sum_array (a: array int) : int =
    sum_sub_array a 0 (length a - 1)

  let rec lemma sum_sub_array_shift (a b: array int) (lo hi: int)
    requires { length a + 1 = length b }
    requires { forall i: int. lo <= i <= hi -> a[i] = b[i+1] }
    ensures  { sum_sub_array a lo hi = sum_sub_array b (lo+1) (hi+1) }
    variant  { hi - lo }
  =
    if lo <= hi then sum_sub_array_shift a b (lo+1) hi

end

module CoqSpec

  type nat (* ? *)
  use import list.List

  type partition = list nat

  predicate inputSpec (inner outer eval: partition)

  predicate outputSpec (inner outer eval: partition) (tab: list (list nat))

end

module LRrule

  use import int.Int
  use import int.MinMax
  use import ref.Refint
  use import map.Map
  use import array.Array
  use import Sum
  use import ArraySum
  use import int.NumOf

  function is_part (shape: array int) : bool =
    (forall i j: int. 0 <= i <= j < length shape -> shape[i] >= shape[j] ) /\
    (shape[length shape - 1] >= 0)

  lemma is_part_nonneg:
    forall sh. is_part sh -> forall i: int. 0 <= i < length sh -> 0 <= sh[i]

  function included (inner: array int) (outer: array int) : bool =
    (length inner = length outer) /\
    (forall i:int. 0 <= i < length outer -> inner[i] <= outer[i])

  let rec lemma sum_le_eq (f g: int -> int) (a b: int)
    requires { forall i. a <= i <= b -> f i <= g i }
    requires { sum a b f = sum a b g }
    ensures  { forall i. a <= i <= b -> f i = g i }
    variant  { b - a }
  = if a < b then sum_le_eq f g (a+1) b

  lemma included_parts_eq:
    forall innev eval.
    included innev eval -> sum_array innev = sum_array eval ->
    forall i. 0 <= i < length innev -> innev[i] = eval[i]

  (** number of i a[i] = v st lo <= i < hi *)
  function numeq (a: array int) (v: int) (lo hi: int) : int =
    numof (\i: int. a[i] = v) lo hi

  predicate is_yam_prefix (w: array int) (len: int) =
    0 <= len <= length w /\
    (forall i: int. 0 <= i < len -> 0 <= w[i]) /\
    (forall p: int. 0 <= p <= len ->
       forall v: int. 0 <= v -> numeq w (v+1) 0 p <= numeq w v 0 p)

  predicate is_yam_of_eval_prefix (eval: array int) (w: array int) (len: int) =
    is_yam_prefix w len /\
    (forall i: int. 0 <= i < len -> 0 <= w[i] < length eval) /\
    (forall v: int. 0 <= v < length eval -> numeq w v 0 len = eval[v])

  predicate is_yam_of_eval (eval: array int) (w: array int) =
    is_yam_of_eval_prefix eval w (length w)

  type skew_shape = {
    outer: array int;
    inner: array int;
    end_of_row: array int;
    end_of_overlap: array int;
    below: array int;
  }

  predicate is_tableau_reading_prefix (s: skew_shape) (w: array int) (len: int) =
    (* each row of the tableau is non-decreasing (from left to right) *)
    (forall r: int. 1 <= r < length s.outer ->
       forall i: int. i < len -> s.end_of_row[r-1] <= i < s.end_of_row[r] - 1 ->
         w[i] >= w[i+1]) /\
    (* each column of the tableau is increasing (from bottom up) *)
    (forall r: int. 1 <= r < length s.outer ->
       forall i: int. i < len -> s.end_of_row[r-1] <= i < s.end_of_overlap[r] ->
         w[i] > w[i - s.below[r]])

  predicate is_tableau_reading (s: skew_shape) (w: array int) =
    is_tableau_reading_prefix s w (length w)

  predicate is_solution_prefix
    (s: skew_shape) (eval: array int) (w: array int) (len: int) =
    is_yam_of_eval_prefix eval w len /\
    is_tableau_reading_prefix s w len

  predicate is_solution (s: skew_shape) (eval: array int) (w: array int) =
    is_yam_of_eval eval w /\
    is_tableau_reading s w

  (** storing solutions we have found so far *)

  (* solutions t and u have the same prefix [0..i[ *)
  predicate eq_prefix (s1 s2: array int) (i: int) =
    forall k: int. 0 <= k < i -> s1[k] = s2[k]

  predicate lt_sol (s1 s2: array int) =
    length s1 = length s2 /\
    exists i: int. 0 <= i < length s1 /\ eq_prefix s1 s2 i /\ s1[i] < s2[i]

  predicate eq_sol (s1 s2: array int) =
    length s1 = length s2 /\
    eq_prefix s1 s2 (length s1)

  lemma lt_not_eq:
    forall s1 s2: array int. lt_sol s1 s2 -> not (eq_sol s1 s2)

  type solution

  function a2s (array int) : solution
  function s2a solution : array int

  axiom a2s2a_def:
    forall a: array int. eq_sol a (s2a (a2s a))

  type solutions = {
    mutable sols: map int solution;
    mutable next: int; (* next slot for a solution *)
  }

  (* s[lo..hi[ is sorted for lt_sol *)
  predicate sorted (s: solutions) (lo hi: int) =
    forall i j: int. lo <= i < j < hi ->
                     lt_sol (s2a (Map.get s.sols i)) (s2a (Map.get s.sols j))

  (* a sorted array of solutions contains no duplicate *)
  lemma no_duplicate:
    forall s: solutions, lo hi: int. sorted s lo hi ->
    forall i j: int. lo <= i < j < hi ->
      not (eq_sol (s2a (Map.get s.sols i)) (s2a (Map.get s.sols j)))

  predicate good_solutions
    (sh: skew_shape) (eval: array int)
    (s: solutions) (lo hi: int)
  =
    sorted s lo hi /\
    forall i. lo <= i < hi -> is_solution sh eval (s2a (Map.get s.sols i))

  val ghost solutions: solutions

  val ghost store_solution (sh: skew_shape) (eval: array int) (w: array int)
    : unit
    requires { is_solution sh eval w }
    writes   { solutions.sols, solutions.next }
    ensures  { solutions.next = (old solutions.next) + 1 }
    ensures  { solutions.sols =
               Map.set (old solutions.sols) (old solutions.next) (a2s w) }

  (** skew shapes *)

  (* outer and inner after add_empty_row *)
  predicate valid_normalized_outer_inner (outer inner: array int) =
    2 <= length outer = length inner /\
    included inner outer /\
    is_part inner /\ is_part outer /\
    outer[0] = inner[0] = outer[1]

  predicate valid_end_of_row (outer inner end_of_row: array int) =
    length end_of_row = length outer /\
    end_of_row[0] = 0 /\
    forall i. 1 <= i < length end_of_row ->
              end_of_row[i] = sum 1 i (\ j. outer[j] - inner[j])

  predicate valid_skew_shape (sh: skew_shape) =
    valid_normalized_outer_inner sh.outer sh.inner /\
    valid_end_of_row sh.outer sh.inner sh.end_of_row /\
    length sh.end_of_overlap = length sh.below = length sh.outer /\
    forall i. 1 <= i < length sh.end_of_overlap ->
      sh.below[i] = sh.outer[i] - sh.inner[i-1] /\
      sh.end_of_overlap[i] = sh.end_of_row[i-1] + sh.below[i]
    (* end_of_overlap[0] and below[0] are left unspecified *)

  let compute_end_of_row (outer inner: array int) : array int
    requires { included inner outer }
    ensures  { valid_end_of_row outer inner result }
  =
    let n = Array.length outer in
    let sums = Array.make n 0 in
    for i = 1 to n-1 do
      invariant { sums[0] = 0 }
      invariant { forall k. 1 <= k < i ->
                  sums[k] = sum 1 k (\j. outer[j] - inner[j]) }
      sums[i] <- sums[i-1] + outer[i] - inner[i]
    done;
    sums

  (*

 szshape = 3

         +--------------+
    2    |       |      |
         +-------+------+-----+
    1            |            |
                 +------------+
    0                         |
                              +
  *)

  predicate valid_eval (eval: array int) =
    1 <= length eval /\ is_part eval /\
    eval[length eval - 1] = 0 (* sentinel: eval ends with a zero *)

  (* TODO: bundle work, innev, and lastinnev in a record *)

  predicate valid_innev (eval innev work: array int) (idx lastinnev: int) =
    length eval = length innev /\
    0 <= lastinnev < length eval /\
    is_part innev /\
    included innev eval /\
    (forall i: int. 0 <= i < idx -> 0 <= work[i] < lastinnev) /\
    (lastinnev = 0 \/ 0 < innev[lastinnev - 1]) /\
    (forall i: int. lastinnev <= i < length innev -> innev[i] = 0)

  let lrrule (sh: skew_shape) (eval: array int) : int
    requires { valid_skew_shape sh }
    requires { valid_eval eval }
    requires { sum_array eval = sum_array sh.outer - sum_array sh.inner }
    requires { solutions.next = 0 }
    ensures  { result = solutions.next }
    ensures  { good_solutions sh eval solutions 0 result }
    ensures  { forall w. is_solution sh eval w ->
               exists i. 0 <= i < solutions.next /\ eq_sol w (s2a (Map.get solutions.sols i)) }
    diverges
  =
    let n = sh.end_of_row[Array.length sh.end_of_row - 1] in
    assert { 0 <= n };
    let szshape = Array.length sh.outer in (* = Array.length inner *)
    let szeval = Array.length eval in
    let innev = Array.make szeval 0 in
    let lastinnev = ref 0 in (* only zeros from this index *)
    let work = Array.make n 0 in
    (* row = current row
       idx = current index in work, from the start *)
    let rec count_rec (row idx: int)
      requires { 1 <= row <= szshape = length sh.outer }
      requires { row < szshape -> sh.end_of_row[row-1] <= idx <= sh.end_of_row[row] }
      requires { valid_innev eval innev work idx !lastinnev }
      requires { is_solution_prefix sh eval work idx }
      diverges
      ensures  { forall i. 0 <= i < length innev -> innev[i] = (old innev)[i] }
      ensures  { forall i. 0 <= i < idx -> work[i] = (old work)[i] }
      ensures  { !lastinnev = old !lastinnev }
      ensures  { result = solutions.next - old solutions.next }
      ensures  { sorted solutions (old solutions.next) solutions.next }
      ensures  { forall i. old solutions.next <= i < solutions.next ->
                 let w = s2a (Map.get solutions.sols i) in
                 is_solution sh eval w /\ eq_prefix (old work) w idx }
      ensures  { forall w. is_solution sh eval w -> eq_prefix (old work) w idx ->
                 exists i. old solutions.next <= i < solutions.next /\
                           eq_sol w (s2a (Map.get solutions.sols i)) }
      =
      assert { sh.end_of_overlap[1] = 0 };
      assert { forall row idx.
               2 <= row < length sh.below ->
               sh.end_of_row[row-1] <= idx < sh.end_of_overlap[row] ->
               sh.end_of_row[row-2] <= idx - sh.below[row] < sh.end_of_row[row-1] };
      if row = szshape then begin
        (* found a solution *)
        assert { idx = n };
        ghost store_solution sh eval work;
        1
      end
      else if idx = sh.end_of_row[row] then
        (* move from row [row-1] to row [row] *)
        count_rec (row + 1) idx
      else begin
        let min = abstract ensures { result =
            if idx < sh.end_of_overlap[row] then work[idx - sh.below[row]] + 1 else 0
          } if idx < sh.end_of_overlap[row] then work[idx - sh.below[row]] + 1 else 0
          end in
        let max = abstract ensures { result =
          if idx = sh.end_of_row[row-1] then !lastinnev
          else MinMax.min !lastinnev work[idx - 1] }
          if idx = sh.end_of_row[row-1] then !lastinnev
          else MinMax.min !lastinnev work[idx - 1]
        end in
        assert { forall w. is_solution sh eval w -> eq_prefix work w idx ->
                 min <= w[idx] <= max };
        let sum = ref 0 in
        'Init:
        for v = min to max do
          invariant { !lastinnev = at !lastinnev 'Init }
          invariant { forall i. 0 <= i < length innev ->
                      innev[i] = (at innev 'Init)[i] }
          invariant { forall i. 0 <= i < idx -> work[i] = (at work 'Init)[i] }
          invariant { valid_innev eval innev work idx !lastinnev }
          invariant { "expl: is_yam" is_yam_prefix work idx }
          invariant { is_tableau_reading_prefix sh work idx }
          invariant { !sum = solutions.next - at solutions.next 'Init }
          invariant { sorted solutions (at solutions.next 'Init) solutions.next }
          invariant { forall i. at solutions.next 'Init <= i < solutions.next ->
                      let w = s2a (Map.get solutions.sols i) in
                      is_solution sh eval w /\ eq_prefix (at work 'Init) w idx /\
                      min <= w[idx] < v }
          invariant { forall w. is_solution sh eval w -> eq_prefix (at work 'Init) w idx ->
                      min <= w[idx] < v ->
                      exists i. at solutions.next 'Init <= i < solutions.next /\
                                eq_sol w (s2a (Map.get solutions.sols i)) }
        if innev[v] < eval[v] && (v = 0 || innev[v-1] > innev[v]) then begin
            innev[v] <- innev[v] + 1;
            if v = !lastinnev then lastinnev += 1;
            assert { 0 <= v < !lastinnev };
            work[idx] <- v;
            sum += count_rec row (idx+1);
            innev[v] <- innev[v] - 1;
            if !lastinnev = v+1 && innev[v] = 0 then lastinnev -= 1
          end
        done;
        !sum
      end
    in count_rec 1 0

  let add_empty_row
    (outer: array int) (inner: array int) : (array int, array int)
    requires { 1 <= length outer = length inner }
    requires { included inner outer}
    ensures  { let (out, inn) = result in
               length out = length inn = 1 + length outer }
    ensures  { let (out, inn) = result in
               out[0] = inn[0] = outer[0] /\
               forall k. 1 <= k <= length outer ->
                 out[k] = outer[k-1] /\ inn[k] = inner[k-1] }
    ensures  { let (out, inn) = result in
		sum_array out = outer [0] + sum_array outer /\
		sum_array inn = outer [0] + sum_array inner }
    ensures  { let (out, inn) = result in included inn out }
  = let sz = Array.length outer in
    let n = outer[0] in
    let out = Array.make (sz + 1) n in
    let inn = Array.make (sz + 1) n in
    for k = 1 to sz do
      invariant { out[0] = inn[0] = outer[0] }
      invariant { forall j. 1 <= j < k ->
                  out[j] = outer[j-1] /\ inn[j] = inner[j-1] }
      out[k] <- outer[k - 1]; inn[k] <- inner[k - 1]
    done;
    (out, inn)

  let compute_skew_shape (outer inner: array int) : skew_shape
    requires { 1 <= length outer = length inner }
    requires { included inner outer }
    requires { is_part inner /\ is_part outer }
    ensures  { valid_skew_shape result }
    ensures  { length result.outer = length result.inner = 1 + length outer }
    ensures  { result.outer[0] = result.inner[0] = outer[0] /\
               forall k. 1 <= k <= length outer ->
                 result.outer[k] = outer[k-1] /\ result.inner[k] = inner[k-1] }
    ensures  { sum_array result.outer = outer [0] + sum_array outer }
    ensures  { sum_array result.inner = outer [0] + sum_array inner }
  =
    let (outer, inner) = add_empty_row outer inner in
    assert { valid_normalized_outer_inner outer inner };
    let end_of_row = compute_end_of_row outer inner in
    let n = Array.length outer in
    let eoo = Array.make n 0 in
    let below = Array.make n 0 in
    for r = 1 to n-1 do
      invariant { forall i. 1 <= i < r ->
        below[i] = outer[i] - inner[i-1] /\
        eoo[i] = end_of_row[i-1] + below[i] }
      below[r] <- outer[r] - inner[r-1];
      eoo[r] <- end_of_row[r-1] + below[r]
    done;
    { outer = outer; inner = inner; end_of_row = end_of_row;
      end_of_overlap = eoo; below = below }

  let lrrule2 outer inner eval
    requires { 1 <= length outer = length inner }
    requires { included inner outer }
    requires { is_part inner /\ is_part outer }
    requires { valid_eval eval }
    requires { sum_array eval = sum_array outer - sum_array inner }
    diverges
  =
    let sh = compute_skew_shape outer inner in
    ghost solutions.next <- 0;
    lrrule sh eval

end

(*
Local Variables:
compile-command: "why3 ide lrrule"
End:
*)
