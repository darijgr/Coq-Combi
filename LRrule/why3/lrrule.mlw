
module LRrule

  use import int.Int
  use import int.MinMax
  use import ref.Refint
  use import array.Array

  function is_part (shape: array int) : bool =
    (forall i:int. 1 <= i < length shape -> shape[i-1] >= shape[i] ) /\
    (shape[length shape - 1] >= 0)

  function included (inner: array int) (outer: array int) : bool =
    (length inner = length outer) /\
    (forall i:int. 0 <= i < length outer -> inner[i] <= outer[i])


  let diff_shape (outer: array int) (inner: array int) : array int
    requires { length inner = length outer }
    ensures  { length result = length outer }
    ensures  { forall i:int. 0 <= i < length result -> result[i] = outer[i] - inner[i] }
    (* I'm not sure we want the following here, since it could be deduced from the *)
    (* previous postcondition. Is it possible to have it as an outside lemma ?     *)
    requires { included inner outer }
    ensures  { forall i:int. 0 <= i < length result -> result[i] >= 0 }
   =
    let res = copy outer in
    for i = 0 to length outer - 1 do
      invariant { forall j:int. 0 <= j < i -> res[j] = outer[j] - inner[j] }
      invariant { forall j:int. i <= j < length res -> res[j] = outer[j] }
      res[i] <- res[i] - inner[i]
    done;
    res


  let compute_end_of_row (outer inner: array int) : array int
    requires { included inner outer }
    ensures  { length result = length outer }
  =
    let ds = diff_shape outer inner in
    let n = Array.length ds in
    let sums = Array.make n 0 in
    for i = 1 to n-1 do sums[i] <- sums[i-1] + ds[i] done;
    sums


  let compute_end_of_overlap (outer inner end_of_row: array int) : (array int, array int)
    requires { length outer = length inner }
    requires { length outer = length end_of_row }
  =
    let n = Array.length outer in
    let eoo = Array.make n 0 in
    let below = Array.make n 0 in
    for r = 1 to n-1 do
      below[r] <- outer[r] - inner[r-1];
      eoo[r] <- end_of_row[r-1] + below[r]
    done;
    (eoo, below)


  let add_empty_row (outer: array int) (inner: array int) : (array int, array int)
    requires { 1 <= length outer = length inner }
    ensures  { let (o, i) = result in length o = length i = 1 + length outer }
  = let sz = Array.length outer in
    let n = outer[0] in
    let o = Array.make (sz + 1) n in
    let i = Array.make (sz + 1) n in
    for k = 1 to sz do o[k] <- outer[k - 1]; i[k] <- inner[k - 1] done;
    (o, i)

  let lrrule (outer: array int) (inner: array int) (eval: array int) : int
    requires { length outer = length inner }
  =
    let (outer, inner) = add_empty_row outer inner in
    let end_of_row = compute_end_of_row outer inner in
    let n = end_of_row[Array.length end_of_row - 1] in
    let (end_of_overlap, below) = compute_end_of_overlap outer inner end_of_row in
    let szshape = Array.length outer in (* = Array.length inner *)
    let szeval = Array.length eval in
    let innev = Array.make szeval 0 in
    let lastinnev = ref 0 in (* only zeros from this index *)
    let work = Array.make n 0 in
    let compute_bounds (row idx: int) =
      let min = if idx < end_of_overlap[row] then work[idx - below[row]] + 1 else 0 in
      let max = if idx = end_of_row[row-1] then !lastinnev
        else MinMax.min !lastinnev work[idx - 1] in
      (min, max)
    in
    (* row = current row in work
       idx = current index in row, from the end *)
    let rec count_rec (row idx: int) =
      (* move from row [row-1] to row [row] *)
      if row = szshape then 1
      else if idx = end_of_row[row] then count_rec (row + 1) idx
      else begin
        let (min, max) = compute_bounds row idx in
        let sum = ref 0 in
        for v = min to max do
          if innev[v] < eval[v] && (v = 0 || innev[v-1] > innev[v]) then begin
            innev[v] <- innev[v] + 1;
            if v = !lastinnev then lastinnev += 1;
            work[idx] <- v;
            sum += count_rec row (idx+1);
            innev[v] <- innev[v] - 1;
            if !lastinnev = v+1 && innev[v] = 0 then lastinnev -= 1
          end
        done;
        !sum
      end
    in count_rec 1 0

end
