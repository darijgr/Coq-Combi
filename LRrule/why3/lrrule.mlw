
(*
   Alt-Ergo 0.99.1
   CVC4 1.4
   Z3 4.3.2
   Coq 8.4pl5
*)

theory Sum

  use import int.Int
  use HighOrd

  function sum (a b: int) (f: int -> int) : int
  (** sum of [f n] for [a <= n <= b] *)

  axiom sum_def1:
    forall f: int -> int, a b: int.
    b < a -> sum a b f = 0

  axiom sum_def2:
    forall f: int -> int, a b: int.
    a <= b -> sum a b f = sum a (b - 1) f + f b

  lemma sum_left:
    forall f: int -> int, a b: int.
    a <= b -> sum a b f = f a + sum (a + 1) b f

  lemma sum_ext:
    forall f g: int -> int, a b: int.
    (forall i. a <= i <= b -> f i = g i) ->
    sum a b f = sum a b g

  lemma sum_nonneg:
    forall f: int -> int, a b: int.
    (forall i. a <= i <= b -> 0 <= f i) ->
    0 <= sum a b f

  lemma sum_decomp:
    forall f: int -> int, a b c: int. a <= b <= c ->
    sum a c f = sum a b f + sum (b+1) c f

end

module ArraySum

  use import int.Int
  use import array.Array
  use import Sum

  function sum_sub_array (a: array int) (lo hi: int) : int =
    sum lo hi (\i: int. a[i])

  function sum_array (a: array int) : int =
    sum_sub_array a 0 (length a - 1)

  let rec lemma sum_sub_array_shift (a b: array int) (lo hi: int)
    requires { length a + 1 = length b }
    requires { forall i: int. lo <= i <= hi -> a[i] = b[i+1] }
    ensures  { sum_sub_array a lo hi = sum_sub_array b (lo+1) (hi+1) }
    variant  { hi - lo }
  =
    if lo <= hi then sum_sub_array_shift a b (lo+1) hi

end

module CoqSpec

  type nat (* ? *)
  use import list.List

  type partition = list nat

  predicate inputSpec (inner outer eval: partition)

  predicate outputSpec (inner outer eval: partition) (tab: list (list nat))

end

module LRrule

  use import int.Int
  use import int.MinMax
  use import ref.Refint
  use import map.Map
  use import array.Array
  use import Sum
  use import ArraySum
  use import int.NumOf

  function is_part (shape: array int) : bool =
    (forall i j: int. 0 <= i <= j < length shape -> shape[i] >= shape[j] ) /\
    (shape[length shape - 1] >= 0)

  lemma is_part_nonneg:
    forall sh. is_part sh -> forall i: int. 0 <= i < length sh -> 0 <= sh[i]

  function included (inner: array int) (outer: array int) : bool =
    (length inner = length outer) /\
    (forall i:int. 0 <= i < length outer -> inner[i] <= outer[i])

  (** number of i a[i] = v st lo <= i < hi *)
  function numeq (a: array int) (v: int) (lo hi: int) : int =
    numof (\i: int. a[i] = v) lo hi

  predicate is_yam_prefix (w: array int) (len: int) =
    0 <= len <= length w /\
    (forall i: int. 0 <= i < len -> 0 <= w[i]) /\
    (forall p: int. 0 <= p <= len ->
       forall v: int. 0 <= v -> numeq w (v+1) 0 p <= numeq w v 0 p)

  predicate is_yam_of_eval (eval: array int) (w: array int) =
    is_yam_prefix w (length w) /\
    (forall i: int. 0 <= i < length w -> 0 <= w[i] < length eval) /\
    (forall v: int. 0 <= v < length eval -> numeq w v 0 (length w) = eval[v])

  type skew_shape = {
    outer: array int;
    inner: array int;
    end_of_row: array int;
    end_of_overlap: array int;
    below: array int;
  }

  predicate is_tableau_reading_prefix (s: skew_shape) (w: array int) (len: int) =
    (* each row of the tableau is non-decreasing (from left to right) *)
    (forall r: int. 1 <= r < length s.outer ->
       forall i: int. i < len -> s.end_of_row[r-1] <= i < s.end_of_row[r] - 1 ->
         w[i] >= w[i+1]) /\
    (* each column of the tableau is increasing (from bottom up) *)
    (forall r: int. 1 <= r < length s.outer ->
       forall i: int. i < len -> s.end_of_row[r-1] <= i < s.end_of_overlap[r] ->
         w[i] > w[i - s.below[r]])

  predicate is_tableau_reading (s: skew_shape) (w: array int) =
    is_tableau_reading_prefix s w (length w)

  predicate is_solution (s: skew_shape) (eval: array int) (w: array int) =
    is_yam_of_eval eval w /\
    is_tableau_reading s w

  (** storing solutions we have found so far *)

  type solution = array int

  (* solutions t and u have the same prefix [0..i[ *)
  predicate eq_prefix (t u: solution) (i: int) =
    forall k: int. 0 <= k < i -> t[k] = u[k]

  predicate lt_sol (s1 s2: solution) =
    length s1 = length s2 /\
    exists i: int. 0 <= i < length s1 /\ eq_prefix s1 s2 i /\ s1[i] < s2[i]

  predicate eq_sol (t u: solution) =
    length t = length u /\
    eq_prefix t u (length t)

(***
  type solutions = {
    mutable sols: map int (map int int);
    mutable next: int; (* next slot for a solution *)
  }

  val ghost solutions: solutions

  let ghost store_solution (sh: skew_shape) (eval: array int) (w: solution)
    : unit
    requires { is_solution sh eval w }
    writes   { solutions.sols, solutions.next }
    ensures  { solutions.next = (old solutions.next) + 1 }
    ensures  { solutions.sols =
               Map.set (old solutions.sols) (old solutions.next) w.elts }
  =
    solutions.sols <- Map.set solutions.sols solutions.next w.elts;
    solutions.next <- solutions.next + 1

  (* s[a..b[ is sorted for lt_sol *)
  predicate sorted (s: solutions) (a b: int) =
    forall i j: int. a <= i < j < b -> lt_sol (Map.get s i) (Map.get s j)

  (* a sorted array of solutions contains no duplicate *)
  lemma no_duplicate:
    forall s: solutions, a b: int. sorted s a b ->
    forall i j: int. a <= i < j < b -> not (eq_sol (Map.get s i) (Map.get s j))
***)

  (** skew shapes *)

  predicate valid_end_of_row (outer inner end_of_row: array int) =
    length end_of_row = length outer /\
    end_of_row[0] = 0 /\
    forall i. 1 <= i < length end_of_row ->
              end_of_row[i] = sum 1 i (\ j. outer[j] - inner[j])

  predicate valid_skew_shape (s: skew_shape) =
    valid_end_of_row s.outer s.inner s.end_of_row /\
    length s.end_of_overlap = length s.below = length s.outer /\
    forall i. 1 <= i < length s.end_of_overlap ->
      s.below[i] = s.outer[i] - s.inner[i-1] /\
      s.end_of_overlap[i] = s.end_of_row[i-1] + s.below[i]
    (* end_of_overlap[0] and below[0] are left unspecified *)

  let compute_end_of_row (outer inner: array int) : array int
    requires { included inner outer }
    ensures  { valid_end_of_row outer inner result }
  =
    let n = Array.length outer in
    let sums = Array.make n 0 in
    for i = 1 to n-1 do
      invariant { sums[0] = 0 }
      invariant { forall k. 1 <= k < i ->
                  sums[k] = sum 1 k (\j. outer[j] - inner[j]) }
      sums[i] <- sums[i-1] + outer[i] - inner[i]
    done;
    sums

  let compute_skew_shape (outer inner: array int) : skew_shape
    requires { included inner outer }
    ensures  { valid_skew_shape result }
    ensures  { result.outer = outer }
    ensures  { result.inner = inner }
  =
    let end_of_row = compute_end_of_row outer inner in
    let n = Array.length outer in
    let eoo = Array.make n 0 in
    let below = Array.make n 0 in
    for r = 1 to n-1 do
      invariant { forall i. 1 <= i < r ->
        below[i] = outer[i] - inner[i-1] /\
        eoo[i] = end_of_row[i-1] + below[i] }
      below[r] <- outer[r] - inner[r-1];
      eoo[r] <- end_of_row[r-1] + below[r]
    done;
    { outer = outer; inner = inner; end_of_row = end_of_row;
      end_of_overlap = eoo; below = below }

  (*

 szshape = 3

         +--------------+
    2    |       |      |
         +-------+------+-----+
    1            |            |
                 +------------+
    0                         |
                              +
  *)

  (* outer and inner after add_empty_row *)
  predicate valid_arrays_data (outer inner: array int) =
    2 <= length outer = length inner /\
    included inner outer /\
    is_part inner /\ is_part outer /\
    outer[0] = inner[0] = outer[1]

  predicate valid_eval (eval: array int) =
    1 <= length eval /\ is_part eval /\
    eval[length eval - 1] = 0 (* sentinel: eval ends with a zero *)

  (* TODO: bundle work, innev, and lastinnev in a record *)

  predicate valid_innev (eval innev work: array int) (idx lastinnev: int) =
    length eval = length innev /\
    0 <= lastinnev < length eval /\
    is_part innev /\
    included innev eval /\
    (forall i: int. 0 <= i < idx -> 0 <= work[i] < lastinnev) /\
    (lastinnev = 0 \/ 0 < innev[lastinnev - 1]) /\
    (forall i: int. lastinnev <= i < length innev -> innev[i] = 0)

  let lrrule (outer: array int) (inner: array int) (eval: array int) : int
    requires { valid_arrays_data outer inner }
    requires { valid_eval eval }
    requires { sum_array eval = sum_array outer - sum_array inner }
    diverges
  =
    let sh = compute_skew_shape outer inner in
    let n = sh.end_of_row[Array.length sh.end_of_row - 1] in
    assert { 0 <= n };
    let szshape = Array.length outer in (* = Array.length inner *)
    let szeval = Array.length eval in
    let innev = Array.make szeval 0 in
    let lastinnev = ref 0 in (* only zeros from this index *)
    let work = Array.make n 0 in
    (* row = current row
       idx = current index in work, from the start *)
    let rec count_rec (row idx: int)
      requires { 1 <= row <= szshape = length outer }
      requires { row < szshape -> sh.end_of_row[row-1] <= idx <= sh.end_of_row[row] }
      requires { valid_innev eval innev work idx !lastinnev }
      requires { is_yam_prefix work idx }
      requires { is_tableau_reading_prefix sh work idx }
      diverges
      ensures  { forall i. 0 <= i < length innev -> innev[i] = (old innev)[i] }
      ensures  { forall i. 0 <= i < idx -> work[i] = (old work)[i] }
      ensures  { !lastinnev = old !lastinnev }
      =
      assert { sh.end_of_overlap[1] = 0 };
      assert { forall row idx.
               2 <= row < length sh.below ->
               sh.end_of_row[row-1] <= idx < sh.end_of_overlap[row] ->
               sh.end_of_row[row-2] <= idx - sh.below[row] < sh.end_of_row[row-1] };
      if row = szshape then begin
        (* found a solution *)
        assert { idx = n };
        assert { is_solution sh eval work };
        1
      end
      else if idx = sh.end_of_row[row] then
        (* move from row [row-1] to row [row] *)
        count_rec (row + 1) idx
      else begin
        let min = abstract ensures { result =
            if idx < sh.end_of_overlap[row] then work[idx - sh.below[row]] + 1 else 0
          } if idx < sh.end_of_overlap[row] then work[idx - sh.below[row]] + 1 else 0
          end in
        let max = abstract ensures { result =
          if idx = sh.end_of_row[row-1] then !lastinnev
          else MinMax.min !lastinnev work[idx - 1] }
          if idx = sh.end_of_row[row-1] then !lastinnev
          else MinMax.min !lastinnev work[idx - 1]
        end in
        let sum = ref 0 in
        'Init:
        for v = min to max do
          invariant { !lastinnev = at !lastinnev 'Init }
          invariant { forall i. 0 <= i < length innev ->
                      innev[i] = (at innev 'Init)[i] }
          invariant { forall i. 0 <= i < idx -> work[i] = (at work 'Init)[i] }
          invariant { valid_innev eval innev work idx !lastinnev }
          invariant { is_yam_prefix work idx }
          invariant { is_tableau_reading_prefix sh work idx }
        if innev[v] < eval[v] && (v = 0 || innev[v-1] > innev[v]) then begin
            innev[v] <- innev[v] + 1;
            if v = !lastinnev then lastinnev += 1;
            assert { 0 <= v < !lastinnev };
            work[idx] <- v;
            sum += count_rec row (idx+1);
            innev[v] <- innev[v] - 1;
            if !lastinnev = v+1 && innev[v] = 0 then lastinnev -= 1
          end
        done;
        !sum
      end
    in count_rec 1 0

  let add_empty_row
    (outer: array int) (inner: array int) : (array int, array int)
    requires { 1 <= length outer = length inner }
    ensures  { let (out, inn) = result in
               length out = length inn = 1 + length outer }
    ensures  { let (out, inn) = result in
               out[0] = inn[0] = outer[0] /\
               forall k. 1 <= k <= length outer ->
                 out[k] = outer[k-1] /\ inn[k] = inner[k-1] }
    ensures  { (* We are missing a lemma here *)
               let (out, inn) = result in
		sum_array out = outer [0] + sum_array outer /\
		sum_array inn = outer [0] + sum_array inner }
    requires { included inner outer}
    ensures  { let (out, inn) = result in included inn out }
  = let sz = Array.length outer in
    let n = outer[0] in
    let out = Array.make (sz + 1) n in
    let inn = Array.make (sz + 1) n in
    for k = 1 to sz do
      invariant { out[0] = inn[0] = outer[0] }
      invariant { forall j. 1 <= j < k ->
                  out[j] = outer[j-1] /\ inn[j] = inner[j-1] }
      out[k] <- outer[k - 1]; inn[k] <- inner[k - 1]
    done;
    (out, inn)

  let lrrule2 outer inner eval
    requires { 1 <= length outer = length inner }
    requires { included inner outer }
    requires { is_part inner /\ is_part outer }
    requires { valid_eval eval }
    requires { sum_array eval = sum_array outer - sum_array inner }
    diverges
  =
    let (outer, inner) = add_empty_row outer inner in
    assert { valid_arrays_data outer inner };
    lrrule outer inner eval

end

(*
Local Variables:
compile-command: "why3 ide lrrule"
End:
*)
