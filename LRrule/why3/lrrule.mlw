
(*
   Alt-Ergo 0.99.1
   CVC4 1.4
   Z3 4.3.2
   Coq 8.4pl5
*)

theory Sum

  use import int.Int
  use HighOrd

  function sum (a b: int) (f: int -> int) : int
  (** sum of [f n] for [a <= n < b] *)

  axiom sum_def1:
    forall f: int -> int, a b: int.
    b <= a -> sum a b f = 0

  axiom sum_def2:
    forall f: int -> int, a b: int.
    a < b -> sum a b f = sum a (b - 1) f + f (b - 1)

  lemma sum_left:
    forall f: int -> int, a b: int.
    a < b -> sum a b f = f a + sum (a + 1) b f

  lemma sum_ext:
    forall f g: int -> int, a b: int.
    (forall i. a <= i < b -> f i = g i) ->
    sum a b f = sum a b g

  lemma sum_le:
    forall f g: int -> int, a b: int.
    (forall i. a <= i < b -> f i <= g i) ->
    sum a b f <= sum a b g

  lemma sum_nonneg:
    forall f: int -> int, a b: int.
    (forall i. a <= i < b -> 0 <= f i) ->
    0 <= sum a b f

  lemma sum_decomp:
    forall f: int -> int, a b c: int. a <= b <= c ->
    sum a c f = sum a b f + sum b c f

end

module ArraySum

  use import int.Int
  use import array.Array
  use import Sum

  function sum_sub_array (a: array int) (lo hi: int) : int =
    sum lo hi (\i: int. a[i])

  function sum_array (a: array int) : int =
    sum_sub_array a 0 (length a)

  let rec lemma sum_sub_array_shift (a b: array int) (lo hi: int)
    requires { length a + 1 = length b }
    requires { forall i: int. lo <= i < hi -> a[i] = b[i+1] }
    ensures  { sum_sub_array a lo hi = sum_sub_array b (lo+1) (hi+1) }
    variant  { hi - lo }
  =
    if lo < hi then sum_sub_array_shift a b (lo+1) hi

   let rec lemma sum_array_sub (a b: array int) (lo hi: int)
     requires { length a = length b }
     ensures  { sum lo hi (\ i . b[i] - a[i]) =
                sum_sub_array b lo hi - sum_sub_array a lo hi }
     variant  { hi - lo }
   =
    if lo < hi then sum_array_sub a b (lo+1) hi

end

module Spec

  use import int.Int
  use import map.Map
  use import array.Array
  use import matrix.Matrix
  use import Sum
  use import ArraySum
  use import int.NumOf

  predicate is_part (shape: array int) =
    1 <= length shape /\
    (forall i j: int. 0 <= i <= j < length shape -> shape[i] >= shape[j] ) /\
    (shape[length shape - 1] >= 0)

  lemma is_part_nonneg:
    forall sh. is_part sh -> forall i: int. 0 <= i < length sh -> 0 <= sh[i]

  predicate included (inner: array int) (outer: array int) =
    (length inner = length outer) /\
    (forall i:int. 0 <= i < length outer -> inner[i] <= outer[i])

  let rec lemma sum_le_eq (f g: int -> int) (a b: int)
    requires { forall i. a <= i < b -> f i <= g i }
    requires { sum a b f = sum a b g }
    ensures  { forall i. a <= i < b -> f i = g i }
    variant  { b - a }
  = if a < b then sum_le_eq f g (a+1) b

  lemma included_parts_eq:
    forall innev eval.
    included innev eval -> sum_array innev = sum_array eval ->
    forall i. 0 <= i < length innev -> innev[i] = eval[i]

  (** number of i a[i] = v st lo <= i < hi *)
  function numeq (a: array int) (v: int) (lo hi: int) : int =
    numof (\i: int. a[i] = v) lo hi

  let rec lemma numeq_shift (a1 a2: array int) (v lo hi: int) : unit
    requires { forall i. lo <= i < hi -> a1[i] = a2[i+1] }
    ensures  { numeq a1 v lo hi = numeq a2 v (lo+1) (hi+1) } variant { hi - lo }
  = if lo < hi then numeq_shift a1 a2 v (lo+1) hi

  predicate valid_input (outer inner: array int) =
    included inner outer /\
    is_part inner /\ is_part outer

  predicate eq_prefix (s1 s2: array int) (i: int) =
    forall k: int. 0 <= k < i -> s1[k] = s2[k]

  predicate eq_array (s1 s2: array int) =
    length s1 = length s2 /\
    eq_prefix s1 s2 (length s1)

  predicate valid_eval (eval: array int) =
    1 <= length eval /\ is_part eval /\
    eval[length eval - 1] = 0 (* sentinel: eval ends with a zero *)

  predicate valid_innev
    (outer inner eval innev: array int)
    (work: matrix int) (row idx lastinnev: int)
  = 0 <= lastinnev < length eval /\
    is_part innev /\
    included innev eval /\
    (forall r. 0 <= r < row ->
       forall i. 0 <= i < outer[r] - inner[r] ->
         0 <= Matrix.get work (r, i) < lastinnev) /\
    (row < length outer ->
      forall i. idx < i < outer[row] - inner[row] ->
         0 <= Matrix.get work (row, i) < lastinnev) /\
    (lastinnev = 0 \/ 0 < innev[lastinnev - 1]) /\
    (forall i: int. lastinnev <= i < length innev -> innev[i] = 0)

  lemma is_part_eq:
    forall a1 a2: array int. is_part a1 -> eq_array a1 a2 -> is_part a2

  function width (outer inner: array int) : int -> int =
    \r. outer[r] - inner[r]

  (* two matrices coincide up to cell (row, idx), excluded *)
  predicate frame (outer inner: array int) (w1 w2: matrix int) (row idx: int) =
    (forall r. 0 <= r < row ->
       forall i. 0 <= i < width outer inner r ->
         Matrix.get w2 (r, i) = Matrix.get w1 (r, i))
    /\
    (forall i. idx < i < outer[row] - inner[row] ->
         Matrix.get w2 (row, i) = Matrix.get w1 (row, i))

  lemma valid_innev_framed:
    forall outer inner eval innev work1 work2 row idx lastinnev.
    valid_innev outer inner eval innev work1 row idx lastinnev ->
    frame outer inner work1 work2 row idx ->
    valid_innev outer inner eval innev work2 row idx lastinnev

  lemma frame_weakening:
    forall outer inner work1 work2 row idx.
    frame outer inner work1 work2 row (idx - 1) ->
    frame outer inner work1 work2 row idx

  lemma frame_trans:
    forall outer inner work1 work2 work3 row idx.
    frame outer inner work1 work2 row idx ->
    frame outer inner work2 work3 row idx ->
    frame outer inner work1 work3 row idx

  (* tableau condition *)

  predicate non_decreasing_row_suffix
    (outer inner: array int) (work: matrix int) (r start: int)
  = forall i1 i2. start <= i1 <= i2 < outer[r] - inner[r] ->
                  Matrix.get work (r, i1) <= Matrix.get work (r, i2)

  (* cell (r,i) is smaller than the cell right below, if it exists *)
  predicate increasing_column
    (outer inner: array int) (work: matrix int) (r i: int)
  = r > 0 && i >= inner[r - 1] - inner[r] -> (* if there a cell below *)
    Matrix.get work (r, i) >
    Matrix.get work (r - 1, i - (inner[r - 1] - inner[r])) (* it is smaller *)

  predicate is_tableau_reading_suffix
    (outer inner: array int) (work: matrix int) (row idx: int) =
    (* each row of the tableau is non-decreasing (from left to right) *)
    (forall r. 0 <= r < row ->
       non_decreasing_row_suffix outer inner work r 0) /\
    (row < length outer ->
       non_decreasing_row_suffix outer inner work row (idx + 1)) /\
    (* each column of the tableau is increasing (from bottom up) *)
    (forall r. 1 <= r < row ->
       forall i. 0 <= i < outer[r] - inner[r] ->
         increasing_column outer inner work r i) /\
    (row < length outer ->
      forall i. idx < i < outer[row] - inner[row] ->
        increasing_column outer inner work row i)

  predicate is_tableau_reading (outer inner: array int) (work: matrix int) =
    is_tableau_reading_suffix outer inner work (length outer) 0

  (* matrix -> array *)

  predicate valid_work (outer inner: array int) (w: matrix int) =
    rows w = length outer /\
    (forall r. 0 <= r < length outer ->
               columns w >= outer[r] - inner[r])

  function to_word (outer inner: array int) (w: matrix int) : array int

  axiom to_word_size:
    forall outer inner w. included inner outer -> valid_work outer inner w ->
    length (to_word outer inner w) = sum 0 (length outer) (width outer inner)

  axiom to_word_contents:
    forall outer inner w. included inner outer -> valid_work outer inner w ->
    forall r. 0 <= r < length outer ->
    forall i. 0 <= i < width outer inner r ->
    (to_word outer inner w)[i + sum (r + 1) (length outer) (width outer inner)]
    = Matrix.get w (r, i)

  (* Yamanouchi condition *)

  predicate is_yam_suffix (w: array int) (len: int) =
    let n = length w in
    0 <= len <= n /\
    (forall i: int. n - len <= i < n -> 0 <= w[i]) /\
    (forall p: int. 0 <= p <= len ->
       forall v1 v2. 0 <= v1 <= v2 -> numeq w v2 (n-p) n <= numeq w v1 (n-p) n)

  predicate is_yam_of_eval_suffix (eval: array int) (w: array int) (len: int) =
    let n = length w in
    is_yam_suffix w len /\
    (forall i: int. n - len <= i < n -> 0 <= w[i] < length eval) /\
    (forall v: int. 0 <= v < length eval -> numeq w v (n-len) n = eval[v])

  predicate is_yam_of_eval (eval: array int) (w: array int) =
    is_yam_of_eval_suffix eval w (length w)

  lemma is_yam_of_eval_length:
    forall eval w.
    is_yam_of_eval eval w -> length w = sum_array eval

  (* solution *)

  predicate is_solution_suffix
    (outer inner eval: array int) (w: matrix int) (row idx: int) =
    valid_work outer inner w /\
    let len = sum 0 (row + 1) (width outer inner) - idx - 1 in
    is_yam_of_eval_suffix eval (to_word outer inner w) len /\
    is_tableau_reading_suffix outer inner w row idx

  predicate is_solution (outer inner eval: array int) (w: matrix int) =
    valid_work outer inner w /\
    is_yam_of_eval eval (to_word outer inner w) /\
    is_tableau_reading outer inner w

  lemma solution_length:
    forall outer inner eval w.
    is_solution outer inner eval w ->
    length (to_word outer inner w) = sum_array eval

  (* solutions are found in lexicographic order *)

  predicate eq_rows (outer inner: array int) (w1 w2: matrix int) (row: int) =
    forall r. 0 <= r < row ->
      forall i. 0 <= i < width outer inner r ->
        Matrix.get w1 (r, i) = Matrix.get w2 (r, i)

  predicate lt_sol (outer inner: array int) (w1 w2: matrix int) =
    (* rows w1 = rows w2 = length outer /\ columns w1 = columns w2 /\ *)
    exists row: int.
      0 <= row < length outer /\ eq_rows outer inner w1 w2 row /\
      exists col. 0 <= col < width outer inner row /\
        (forall i. col < i < width outer inner row ->
          Matrix.get w1 (row, i) = Matrix.get w2 (row, i)) /\
        Matrix.get w1 (row, col) < Matrix.get w2 (row, col)

  lemma frame_lt_sol:
    forall outer inner w1 w2 row idx.
    frame outer inner w1 w2 row idx ->
    0 <= row < length outer ->
    0 <= idx < width outer inner row ->
    Matrix.get w1 (row, idx) < Matrix.get w2 (row, idx) ->
    lt_sol outer inner w1 w2

  predicate eq_sol (outer inner: array int) (w1 w2: matrix int) =
    (* rows w1 = rows w2 = length outer /\ columns w1 = columns w2 /\ *)
    eq_rows outer inner w1 w2 (length outer)

  lemma lt_not_eq:
    forall outer inner: array int, w1 w2: matrix int.
    lt_sol outer inner w1 w2 -> not (eq_sol outer inner w1 w2)

  (* a type to store solutions *)

  type solution

  function m2s (matrix int) : solution
  function s2m solution : matrix int

  axiom m2s2m_def:
    forall m: matrix int. s2m (m2s m) = m

  type solutions = {
    mutable sols: map int solution;
    mutable next: int; (* next slot for a solution *)
  }

  (* s[lo..hi[ is sorted for lt_sol *)
  predicate sorted (outer inner: array int) (s: solutions) (lo hi: int) =
    forall i j: int.
      lo <= i < j < hi ->
      lt_sol outer inner (s2m (Map.get s.sols i)) (s2m (Map.get s.sols j))

  (* a sorted array of solutions contains no duplicate *)
  lemma no_duplicate:
    forall outer inner: array int, s: solutions, lo hi: int.
    sorted outer inner s lo hi ->
    forall i j: int. lo <= i < j < hi ->
      not (eq_sol outer inner (s2m (Map.get s.sols i)) (s2m (Map.get s.sols j)))

  predicate good_solutions (outer inner eval: array int) (s: solutions) =
    0 <= s.next /\
    sorted outer inner s 0 s.next (* /\
    (forall i. 0 <= i < s.next ->
      is_solution outer inner eval (s2m (Map.get s.sols i))) /\
    (forall w. is_solution outer inner eval w ->
       exists i. 0 <= i < s.next /\
                 eq_sol outer inner w (s2m (Map.get s.sols i)))
  *)

end

module ToWord
  use import int.Int
  use import int.MinMax
  use import ref.Refint
  use import array.Array
  use import matrix.Matrix
  use import Sum
  use import Spec

  let ghost to_word (outer inner: array int) (w: matrix int) : array int
    requires { included inner outer }
    requires { valid_work outer inner w }
    ensures  { length result = sum 0 (length outer) (width outer inner) }
    ensures  { forall r. 0 <= r < length outer ->
               forall i. 0 <= i < width outer inner r ->
               result[i + sum (r + 1) (length outer) (width outer inner)] =
               Matrix.get w (r, i) }
  =
    let s = length outer in
    let n = ref 0 in
    for r = 0 to s - 1 do invariant { !n = sum 0 r (width outer inner) >= 0 }
      n += outer[r] - inner[r]
    done;
    let a = Array.make !n 0 in
    let start = ref 0 in
    for row = s - 1 downto 0 do
      invariant { !start = sum (row + 1) (length outer) (width outer inner) }
      invariant { forall r. row < r < length outer ->
                  forall i. 0 <= i < width outer inner r ->
                  a[i + sum (r + 1) (length outer) (width outer inner)] =
                  Matrix.get w (r, i) }
      for col = 0 to outer[row] - inner[row] - 1 do
        invariant { forall r. row < r < length outer ->
                    forall i. 0 <= i < width outer inner r ->
                    a[i + sum (r + 1) (length outer) (width outer inner)] =
                    Matrix.get w (r, i) }
        invariant { forall i. 0 <= i < col ->
                    a[i + sum (row + 1) (length outer) (width outer inner)] =
                    Matrix.get w (row, i) }
        a[!start + col] <- Matrix.get w (row, col)
      done;
      start += outer[row] - inner[row]
    done;
    a

end

module LRrule

  use import int.Int
  use import int.MinMax
  use import ref.Refint
  use import array.Array
  use import matrix.Matrix

  use import Sum
  use import ArraySum
  use import Spec

  val ghost solutions: solutions

  val ghost store_solution (outer inner eval: array int) (w: matrix int)
    : unit
    (* requires { is_solution sh eval w } *)
    writes   { solutions.sols, solutions.next }
    ensures  { solutions.next = (old solutions.next) + 1 }
    ensures  { solutions.sols =
               Map.set (old solutions.sols) (old solutions.next) (m2s w) }

  let compute_width (outer inner: array int) : array int
    requires { length outer = length inner }
    ensures  { length result = length outer }
    ensures  { forall j. 0 <= j < length outer ->
    	       result[j] = width outer inner j }
  =
    let n = Array.length outer in
    let a = Array.make n 0 in
    for i = 0 to n - 1 do
      invariant { forall j. 0 <= j < i -> a[j] = width outer inner j }
      a[i] <- outer[i] - inner[i]
    done;
    a

  let max_array (a: array int) : int
    ensures  { forall j. 0 <= j < length a -> a[j] <= result }
  =
    let m = ref 0 in
    for i = 0 to Array.length a - 1 do
      invariant { forall j. 0 <= j < i -> a[j] <= !m }
      if a[i] > !m then m := a[i]
    done;
    !m

  let compute_shift (inner: array int) : array int
    ensures  { length result = length inner }
    ensures  { forall j. 0 < j < length inner ->
    	       result[j] = inner[j - 1] - inner[j] }
  =
    let n = Array.length inner in
    let shift = Array.make n 0 in
    for i = 1 to n - 1 do
      invariant { forall j. 0 < j < i -> shift[j] = inner[j-1] - inner[j] }
      shift[i] <- inner[i-1] - inner[i]
    done;
    shift

  (*
     row = current row, in [0 .. length outer[
     idx = current index in row (from left to left),
           in [0 .. outer[row]-inner[row][

   ^  _____________________
   |  |_______|___        |
  row |  |________|___    |
   |  |    |__________|___|
   0  |_______|___________|
               0 -> idx -->
  *)

  let lrrule (outer inner eval: array int) : int =
    requires { valid_input outer inner }
    requires { valid_eval eval }
    requires { sum_array eval = sum_array outer - sum_array inner }
    requires { solutions.next = 0 }
    ensures  { result = solutions.next }
    ensures  { "expl:good solutions" good_solutions outer inner eval solutions }
    let szshape = Array.length outer in (* = Array.length inner *)
    let width = compute_width outer inner in
    let max_width = max_array width in
    let shift = compute_shift inner in
    let szeval = Array.length eval in
    let innev = Array.make szeval 0 in
    let lastinnev = ref 0 in (* only zeros from this index *)
    let work = Matrix.make szshape max_width 0 in
    let rec count_rec (row idx: int) : int =
      requires { 0 <= row <= szshape }
      requires { if row < szshape then -1 <= idx < width[row] else idx = 0 }
      requires { "expl:valid_innev"
                 valid_innev outer inner eval innev work row idx !lastinnev }
      (* requires { is_solution_suffix sh eval work idx } *)
      variant  { szshape - row, idx }
      ensures  { !lastinnev = old !lastinnev }
      ensures  { forall i. 0 <= i < length innev -> innev[i] = (old innev)[i] }
      ensures  { "expl:frame" frame outer inner (old work) work row idx }
      ensures  { result = solutions.next - old solutions.next >= 0 }
      ensures  { forall i. 0 <= i < old solutions.next ->
                 Map.get solutions.sols i = Map.get (old solutions.sols) i }
      ensures  { "expl:only solutions"
                 forall i. old solutions.next <= i < solutions.next ->
                 let w = s2m (Map.get solutions.sols i) in
                 (* is_solution sh eval w /\ *)
                 frame outer inner (old work) w row idx }
      ensures  { "expl:sorted solutions"
                 sorted outer inner
                   solutions (old solutions.next) solutions.next }
      (*
      ensures  { forall w. is_solution sh eval w ->
                 eq_prefix (old work) w idx ->
                 exists i. old solutions.next <= i < solutions.next /\
                      eq_sol outer inner w (s2m (Map.get solutions.sols i)) }
      *)
      if row = szshape then begin
        (* found a solution *)
        ghost store_solution outer inner eval work;
        1 (* found a solution *)
      end else if idx < 0 then
        (* move from row [row-1] to row [row] *)
        count_rec (row + 1)
	  (if row + 1 < szshape then width[row + 1] - 1 else 0)
      else begin
        let min = abstract ensures { result =
          if row > 0 && idx >= shift[row]
          then Matrix.get work (row - 1, idx - shift[row]) + 1 else 0 }
          if row > 0 && idx >= shift[row]
          then Matrix.get work (row - 1, idx - shift[row]) + 1 else 0 end in
        let max = abstract ensures { result =
          if idx = width[row] - 1 then !lastinnev
          else MinMax.min !lastinnev (Matrix.get work (row, idx + 1)) }
          if idx = width[row] - 1 then !lastinnev
          else MinMax.min !lastinnev (Matrix.get work (row, idx + 1)) end in
        let sum = ref 0 in
        'Init:
        for v = min to max do
          invariant { !lastinnev = at !lastinnev 'Init }
          invariant { forall i. 0 <= i < length innev ->
                      innev[i] = (at innev 'Init)[i] }
          invariant { "expl:frame"
                      frame outer inner (at work 'Init) work row idx }
          invariant { "expl:valid_innev"
                  valid_innev outer inner eval innev work row idx !lastinnev }
          invariant { !sum = solutions.next - at solutions.next 'Init >= 0 }
          invariant { forall i. 0 <= i < at solutions.next 'Init ->
                Map.get solutions.sols i = Map.get (at solutions.sols 'Init) i }
          (*
          invariant { is_tableau_reading_suffix sh work idx }
          *)
          invariant { "expl:only solutions"
                      forall i. at solutions.next 'Init <= i < solutions.next ->
                      let w = s2m (Map.get solutions.sols i) in
                      (* is_solution sh eval w /\ *)
                      frame outer inner (at work 'Init) w row idx /\
                      min <= Matrix.get w (row, idx) < v }
          invariant { "expl:sorted solutions"
                      sorted outer inner
                        solutions (at solutions.next 'Init) solutions.next }
          (*
          invariant { "expl: all solutions"
                      forall w. is_solution sh eval w ->
                      frame outer inner (at work 'Init) w row idx ->
                      min <= Matrix.get w (row, idx) < v ->
                      exists i. at solutions.next 'Init <= i < solutions.next /\
                         frame outer inner w (s2m (Map.get solutions.sols i)) }
          *)
          'L:
          if innev[v] < eval[v] && (v = 0 || innev[v-1] > innev[v]) then begin
            innev[v] <- innev[v] + 1;
            if v = !lastinnev then lastinnev += 1;
            assert { 0 <= v < !lastinnev };
            Matrix.set work (row, idx) v;
            sum += count_rec row (idx - 1);
            innev[v] <- innev[v] - 1;
            assert { eq_array innev (at innev 'L) };
           if !lastinnev = v+1 && innev[v] = 0 then lastinnev -= 1
          end
        done;
        !sum
      end
    in
    count_rec 0 (width[0] - 1)

end

(*
Local Variables:
compile-command: "why3 ide lrrule"
End:
*)
