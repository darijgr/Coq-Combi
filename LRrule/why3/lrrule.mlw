
(*
   Alt-Ergo 0.99.1
   CVC4 1.4
   Z3 4.3.2
   Coq 8.4pl5
*)

theory Sum

  use import int.Int
  use HighOrd

  function sum (a b: int) (f: int -> int) : int
  (** sum of [f n] for [a <= n <= b] *)

  axiom sum_def1:
    forall f: int -> int, a b: int.
    b < a -> sum a b f = 0

  axiom sum_def2:
    forall f: int -> int, a b: int.
    a <= b -> sum a b f = sum a (b - 1) f + f b

  lemma sum_left:
    forall f: int -> int, a b: int.
    a <= b -> sum a b f = f a + sum (a + 1) b f

  lemma sum_ext:
    forall f g: int -> int, a b: int.
    (forall i. a <= i <= b -> f i = g i) ->
    sum a b f = sum a b g

  lemma sum_le:
    forall f g: int -> int, a b: int.
    (forall i. a <= i <= b -> f i <= g i) ->
    sum a b f <= sum a b g

  lemma sum_nonneg:
    forall f: int -> int, a b: int.
    (forall i. a <= i <= b -> 0 <= f i) ->
    0 <= sum a b f

  lemma sum_decomp:
    forall f: int -> int, a b c: int. a <= b <= c ->
    sum a c f = sum a b f + sum (b+1) c f

end

module ArraySum

  use import int.Int
  use import array.Array
  use import Sum

  function sum_sub_array (a: array int) (lo hi: int) : int =
    sum lo hi (\i: int. a[i])

  function sum_array (a: array int) : int =
    sum_sub_array a 0 (length a - 1)

  let rec lemma sum_sub_array_shift (a b: array int) (lo hi: int)
    requires { length a + 1 = length b }
    requires { forall i: int. lo <= i <= hi -> a[i] = b[i+1] }
    ensures  { sum_sub_array a lo hi = sum_sub_array b (lo+1) (hi+1) }
    variant  { hi - lo }
  =
    if lo <= hi then sum_sub_array_shift a b (lo+1) hi

   let rec lemma sum_array_sub (a b: array int) (lo hi: int)
     requires { length a = length b }
     ensures  { sum lo hi (\ i . b[i] - a[i]) =
                sum_sub_array b lo hi - sum_sub_array a lo hi }
     variant  { hi - lo }
   =
    if lo <= hi then sum_array_sub a b (lo+1) hi

end

module Spec

  use import int.Int
  use import map.Map
  use import array.Array
  use import matrix.Matrix
  use import Sum
  use import ArraySum
  use import int.NumOf

  predicate is_part (shape: array int) =
    1 <= length shape /\
    (forall i j: int. 0 <= i <= j < length shape -> shape[i] >= shape[j] ) /\
    (shape[length shape - 1] >= 0)

  lemma is_part_nonneg:
    forall sh. is_part sh -> forall i: int. 0 <= i < length sh -> 0 <= sh[i]

  predicate included (inner: array int) (outer: array int) =
    (length inner = length outer) /\
    (forall i:int. 0 <= i < length outer -> inner[i] <= outer[i])

  let rec lemma sum_le_eq (f g: int -> int) (a b: int)
    requires { forall i. a <= i <= b -> f i <= g i }
    requires { sum a b f = sum a b g }
    ensures  { forall i. a <= i <= b -> f i = g i }
    variant  { b - a }
  = if a < b then sum_le_eq f g (a+1) b

  lemma included_parts_eq:
    forall innev eval.
    included innev eval -> sum_array innev = sum_array eval ->
    forall i. 0 <= i < length innev -> innev[i] = eval[i]

  (** number of i a[i] = v st lo <= i < hi *)
  function numeq (a: array int) (v: int) (lo hi: int) : int =
    numof (\i: int. a[i] = v) lo hi

  predicate valid_input (outer inner: array int) =
    1 <= length outer = length inner /\
    included inner outer /\
    is_part inner /\ is_part outer

(*
  predicate is_yam_prefix (w: array int) (len: int) =
    0 <= len <= length w /\
    (forall i: int. 0 <= i < len -> 0 <= w[i]) /\
    (forall p: int. 0 <= p <= len ->
       (* forall v: int. 0 <= v -> numeq w (v+1) 0 p <= numeq w v 0 p) *)
       forall v1 v2. 0 <= v1 <= v2 -> numeq w v2 0 p <= numeq w v1 0 p)

  predicate is_yam_of_eval_prefix (eval: array int) (w: array int) (len: int) =
    is_yam_prefix w len /\
    (forall i: int. 0 <= i < len -> 0 <= w[i] < length eval) /\
    (forall v: int. 0 <= v < length eval -> numeq w v 0 len = eval[v])

  predicate is_yam_of_eval (eval: array int) (w: array int) =
    is_yam_of_eval_prefix eval w (length w)

  (* TODO: requires commutation of sum and numeq *)
  lemma is_yam_of_eval_length:
    forall eval w.
    is_yam_of_eval eval w -> length w = sum_array eval

  type skew_shape = {
    outer: array int;
    inner: array int;
    end_of_row: array int;
    end_of_overlap: array int;
    below: array int;
  }

  predicate is_tableau_reading_prefix (s: skew_shape) (w: array int) (len: int) =
    (* each row of the tableau is non-decreasing (from left to right) *)
    (forall r: int. 1 <= r < length s.outer ->
       forall i: int. i < len -> s.end_of_row[r-1] <= i < s.end_of_row[r] - 1 ->
         w[i] >= w[i+1]) /\
    (* each column of the tableau is increasing (from bottom up) *)
    (forall r: int. 1 <= r < length s.outer ->
       forall i: int. i < len -> s.end_of_row[r-1] <= i < s.end_of_overlap[r] ->
         w[i] > w[i - s.below[r]])

  predicate is_tableau_reading (s: skew_shape) (w: array int) =
    is_tableau_reading_prefix s w (length w)

  predicate is_solution_prefix
    (s: skew_shape) (eval: array int) (w: array int) (len: int) =
    is_yam_of_eval_prefix eval w len /\
    is_tableau_reading_prefix s w len

  predicate is_solution (s: skew_shape) (eval: array int) (w: array int) =
    is_yam_of_eval eval w /\
    is_tableau_reading s w

  lemma solution_length:
    forall s eval w. valid_skew_shape s ->
    is_solution s eval w -> length w = sum_array eval

  (** storing solutions we have found so far *)

  (* solutions t and u have the same prefix [0..i[ *)
  predicate eq_prefix (s1 s2: array int) (i: int) =
    forall k: int. 0 <= k < i -> s1[k] = s2[k]

  predicate lt_sol (s1 s2: array int) =
    length s1 = length s2 /\
    exists i: int. 0 <= i < length s1 /\ eq_prefix s1 s2 i /\ s1[i] < s2[i]

  predicate eq_sol (s1 s2: array int) =
    length s1 = length s2 /\
    eq_prefix s1 s2 (length s1)

  lemma lt_not_eq:
    forall s1 s2: array int. lt_sol s1 s2 -> not (eq_sol s1 s2)
*)

  type solution

  function m2s (matrix int) : solution
  function s2m solution : matrix int

  axiom m2s2m_def:
    forall m: matrix int. s2m (m2s m) = m

  type solutions = {
    mutable sols: map int solution;
    mutable next: int; (* next slot for a solution *)
  }

(*
  (* s[lo..hi[ is sorted for lt_sol *)
  predicate sorted (s: solutions) (lo hi: int) =
    forall i j: int. lo <= i < j < hi ->
                     lt_sol (s2a (Map.get s.sols i)) (s2a (Map.get s.sols j))

  (* a sorted array of solutions contains no duplicate *)
  lemma no_duplicate:
    forall s: solutions, lo hi: int. sorted s lo hi ->
    forall i j: int. lo <= i < j < hi ->
      not (eq_sol (s2a (Map.get s.sols i)) (s2a (Map.get s.sols j)))

  predicate good_solutions (sh: skew_shape) (eval: array int) (s: solutions) =
    0 <= s.next /\
    sorted s 0 s.next /\
    (forall i. 0 <= i < s.next ->
      is_solution sh eval (s2a (Map.get s.sols i))) /\
    (forall w. is_solution sh eval w ->
       exists i. 0 <= i < s.next /\ eq_sol w (s2a (Map.get s.sols i)))
*)

  predicate valid_eval (eval: array int) =
    1 <= length eval /\ is_part eval /\
    eval[length eval - 1] = 0 (* sentinel: eval ends with a zero *)

  predicate valid_innev
    (outer inner eval innev: array int)
    (work: matrix int) (row idx lastinnev: int) =
    0 <= lastinnev < length eval /\
    is_part innev /\
    included innev eval /\
    (forall r. 0 <= r < row ->
       forall i. outer[0] - outer[r] <= i < outer[0] - inner[r] ->
         0 <= Matrix.get work (r, i) < lastinnev) /\
    (forall i. outer[0] - outer[row] <= i < idx ->
         0 <= Matrix.get work (row, i) < lastinnev) /\
    (lastinnev = 0 \/ 0 < innev[lastinnev - 1]) /\
    (forall i: int. lastinnev <= i < length innev -> innev[i] = 0)

(*
  lemma is_part_eq:
    forall a1 a2: array int. is_part a1 -> eq_sol a1 a2 -> is_part a2
*)

  predicate frame (w1 w2: matrix int) (width row idx: int) =
    "expl:frame"(
    (forall r. 0 <= r < row ->
       forall i. 0 <= i < width ->
         Matrix.get w2 (r, i) = Matrix.get w1 (r, i))
    /\
    (forall i. 0 <= i < idx ->
         Matrix.get w2 (row, i) = Matrix.get w1 (row, i))
   )

end

module LRrule

  use import int.Int
  use import int.MinMax
  use import ref.Refint
  use import array.Array
  use import matrix.Matrix

  use import Sum
  use import ArraySum
  use import Spec

  val ghost solutions: solutions

  val ghost store_solution (outer inner eval: array int) (w: matrix int)
    : unit
    (* requires { is_solution sh eval w } *)
    writes   { solutions.sols, solutions.next }
    ensures  { solutions.next = (old solutions.next) + 1 }
    ensures  { solutions.sols =
               Map.set (old solutions.sols) (old solutions.next) (m2s w) }

  let lrrule (outer inner eval: array int) : int =
    requires { valid_input outer inner }
    requires { valid_eval eval }
    requires { sum_array eval = sum_array outer - sum_array inner }
    let szshape = Array.length outer in (* = Array.length inner *)
    let width = outer[0] in
    let szeval = Array.length eval in
    let innev = Array.make szeval 0 in
    let lastinnev = ref 0 in (* only zeros from this index *)
    let work = Matrix.make szshape width 0 in
    let rec count_rec (row idx: int) : int =
      requires { 0 <= row <= szshape }
      requires { if row < szshape
                 then width - outer[row] <= idx <= width - inner[row]
                 else idx = 0 }
      ensures  { forall i. 0 <= i < length innev -> innev[i] = (old innev)[i] }
      ensures  { frame (old work) work width row idx }
      requires { valid_innev outer inner eval innev work row idx !lastinnev }
      variant  { szshape - row, width - idx }
      ensures  { !lastinnev = old !lastinnev }
      if row = szshape then
        1 (* found a solution *)
      else if idx = width - inner[row] then
        (* move from row [row-1] to row [row] *)
        count_rec (row + 1)
        (if row + 1 < szshape then width - outer[row + 1] else 0)
      else begin
        let min = abstract ensures { result =
          if row > 0 && idx < width - inner[row - 1]
          then Matrix.get work (row - 1, idx) + 1 else 0 }
          if row > 0 && idx < width - inner[row - 1]
          then Matrix.get work (row - 1, idx) + 1 else 0 end in
        let max = abstract ensures { result =
          if idx = width - outer[row] then !lastinnev
          else MinMax.min !lastinnev (Matrix.get work (row, idx - 1)) }
          if idx = width - outer[row] then !lastinnev
          else MinMax.min !lastinnev (Matrix.get work (row, idx - 1)) end in
        let sum = ref 0 in
        'Init:
        for v = min to max do
          invariant { !lastinnev = at !lastinnev 'Init }
          invariant { forall i. 0 <= i < length innev ->
                      innev[i] = (at innev 'Init)[i] }
          invariant { frame (at work 'Init) work width row idx }
          invariant { "expl: valid_innev"
                  valid_innev outer inner eval innev work row idx !lastinnev }
          if innev[v] < eval[v] && (v = 0 || innev[v-1] > innev[v]) then begin
            innev[v] <- innev[v] + 1;
            if v = !lastinnev then lastinnev += 1;
            assert { 0 <= v < !lastinnev };
            Matrix.set work (row, idx) v;
            sum += count_rec row (idx + 1);
            innev[v] <- innev[v] - 1;
            if !lastinnev = v+1 && innev[v] = 0 then lastinnev -= 1
          end
        done;
        !sum
      end
    in
    count_rec 0 0

end

(*
Local Variables:
compile-command: "why3 ide lrrule"
End:
*)
