
(*
   Alt-Ergo 0.99.1
   CVC4 1.4
   Z3 4.3.2
   Coq 8.4pl5
*)

theory Sum

  use import int.Int
  use HighOrd

  function sum (a b: int) (f: int -> int) : int
  (** sum of [f n] for [a <= n < b] *)

  axiom sum_def1:
    forall f: int -> int, a b: int.
    b <= a -> sum a b f = 0

  axiom sum_def2:
    forall f: int -> int, a b: int.
    a < b -> sum a b f = sum a (b - 1) f + f (b - 1)

  lemma sum_left:
    forall f: int -> int, a b: int.
    a < b -> sum a b f = f a + sum (a + 1) b f

  lemma sum_ext:
    forall f g: int -> int, a b: int.
    (forall i. a <= i < b -> f i = g i) ->
    sum a b f = sum a b g

  lemma sum_le:
    forall f g: int -> int, a b: int.
    (forall i. a <= i < b -> f i <= g i) ->
    sum a b f <= sum a b g

  lemma sum_nonneg:
    forall f: int -> int, a b: int.
    (forall i. a <= i < b -> 0 <= f i) ->
    0 <= sum a b f

  lemma sum_decomp:
    forall f: int -> int, a b c: int. a <= b <= c ->
    sum a c f = sum a b f + sum b c f

  lemma sum_zero:
    forall f: int -> int, a b: int.
    (forall i. a <= i < b -> f i = 0) ->
    sum a b f = 0

end

module ArraySum

  use import int.Int
  use import array.Array
  use import Sum

  function sum_sub_array (a: array int) (lo hi: int) : int =
    sum lo hi (\i: int. a[i])

  function sum_array (a: array int) : int =
    sum_sub_array a 0 (length a)

  let rec lemma sum_sub_array_shift (a b: array int) (lo hi: int)
    requires { length a + 1 = length b }
    requires { forall i: int. lo <= i < hi -> a[i] = b[i+1] }
    ensures  { sum_sub_array a lo hi = sum_sub_array b (lo+1) (hi+1) }
    variant  { hi - lo }
  =
    if lo < hi then sum_sub_array_shift a b (lo+1) hi

   let rec lemma sum_array_sub (a b: array int) (lo hi: int)
     requires { length a = length b }
     ensures  { sum lo hi (\ i . b[i] - a[i]) =
                sum_sub_array b lo hi - sum_sub_array a lo hi }
     variant  { hi - lo }
   =
    if lo < hi then sum_array_sub a b (lo+1) hi

end

module Spec

  use import int.Int
  use import map.Map
  use import array.Array
  use import matrix.Matrix
  use import Sum
  use import ArraySum
  use import int.NumOf

  predicate is_part (shape: array int) =
    1 <= length shape /\
    (forall i j: int. 0 <= i <= j < length shape -> shape[i] >= shape[j] ) /\
    (shape[length shape - 1] >= 0)

  lemma is_part_nonneg:
    forall sh. is_part sh -> forall i: int. 0 <= i < length sh -> 0 <= sh[i]

  predicate included (inner: array int) (outer: array int) =
    (length inner = length outer) /\
    (forall i:int. 0 <= i < length outer -> inner[i] <= outer[i])

  let rec lemma sum_le_eq (f g: int -> int) (a b: int)
    requires { forall i. a <= i < b -> f i <= g i }
    requires { sum a b f = sum a b g }
    ensures  { forall i. a <= i < b -> f i = g i }
    variant  { b - a }
  = if a < b then sum_le_eq f g (a+1) b

  lemma included_parts_eq:
    forall innev eval.
    included innev eval -> sum_array innev = sum_array eval ->
    forall i. 0 <= i < length innev -> innev[i] = eval[i]

  (** number of i a[i] = v st lo <= i < hi *)
  function numeq (a: array int) (v: int) (lo hi: int) : int =
    numof (\i: int. a[i] = v) lo hi

  let rec lemma numeq_shift (a1 a2: array int) (v lo hi: int) : unit
    requires { forall i. lo <= i < hi -> a1[i] = a2[i+1] }
    ensures  { numeq a1 v lo hi = numeq a2 v (lo+1) (hi+1) } variant { hi - lo }
  = if lo < hi then numeq_shift a1 a2 v (lo+1) hi

  lemma numeq0:
    forall w k. (forall i. 0 <= i < length w -> w[i] < k) ->
    numeq w k 0 (length w) = 0

  predicate valid_input (outer inner: array int) =
    included inner outer /\
    is_part inner /\ is_part outer

  predicate eq_prefix (s1 s2: array int) (i: int) =
    forall k: int. 0 <= k < i -> s1[k] = s2[k]

  predicate eq_array (s1 s2: array int) =
    length s1 = length s2 /\
    eq_prefix s1 s2 (length s1)

  predicate valid_eval (eval: array int) =
    1 <= length eval /\ is_part eval /\
    eval[length eval - 1] = 0 (* sentinel: eval ends with a zero *)

  predicate valid_innev
    (outer inner eval innev: array int)
    (work: matrix int) (row idx lastinnev: int)
  = 0 <= lastinnev < length eval /\
    is_part innev /\
    included innev eval /\
    (forall r. 0 <= r < row ->
       forall i. 0 <= i < outer[r] - inner[r] ->
         0 <= Matrix.get work r i < lastinnev) /\
    (row < length outer ->
      forall i. idx < i < outer[row] - inner[row] ->
         0 <= Matrix.get work row i < lastinnev) /\
    (lastinnev = 0 \/ 0 < innev[lastinnev - 1]) /\
    (forall i: int. lastinnev <= i < length innev -> innev[i] = 0)

  lemma is_part_eq:
    forall a1 a2: array int. is_part a1 -> eq_array a1 a2 -> is_part a2

  function width (outer inner: array int) : int -> int =
    \r. outer[r] - inner[r]

  (* two matrices coincide up to cell (row, idx), excluded *)
  predicate frame (outer inner: array int) (w1 w2: matrix int) (row idx: int) =
    (forall r. 0 <= r < row ->
       forall i. 0 <= i < width outer inner r ->
         Matrix.get w2 r i = Matrix.get w1 r i)
    /\
    (row < length outer ->
      forall i. idx < i < width outer inner row ->
         Matrix.get w2 row i = Matrix.get w1 row i)

  lemma valid_innev_framed:
    forall outer inner eval innev work1 work2 row idx lastinnev.
    valid_innev outer inner eval innev work1 row idx lastinnev ->
    frame outer inner work1 work2 row idx ->
    valid_innev outer inner eval innev work2 row idx lastinnev

  lemma frame_weakening:
    forall outer inner work1 work2 row idx.
    frame outer inner work1 work2 row (idx - 1) ->
    frame outer inner work1 work2 row idx

  lemma frame_trans:
    forall outer inner work1 work2 work3 row idx.
    frame outer inner work1 work2 row idx ->
    frame outer inner work2 work3 row idx ->
    frame outer inner work1 work3 row idx

  (* tableau condition *)

  predicate non_decreasing_row_suffix
    (outer inner: array int) (work: matrix int) (r start: int)
  = forall i1 i2. start <= i1 <= i2 < width outer inner r ->
                  Matrix.get work r i1 <= Matrix.get work r i2

  (* cell (r,i) is smaller than the cell right below, if it exists *)
  predicate increasing_column
    (outer inner: array int) (work: matrix int) (r i: int)
  = r > 0 && i >= inner[r - 1] - inner[r] -> (* if there a cell below *)
    Matrix.get work r i >
    Matrix.get work (r - 1) (i - (inner[r - 1] - inner[r])) (* it is smaller *)

  predicate is_tableau_reading_suffix
    (outer inner: array int) (work: matrix int) (row idx: int) =
    (* each row of the tableau is non-decreasing (from left to right) *)
    (forall r. 0 <= r < row ->
       non_decreasing_row_suffix outer inner work r 0) /\
    (row < length outer ->
       non_decreasing_row_suffix outer inner work row (idx + 1)) /\
    (* each column of the tableau is increasing (from bottom up) *)
    (forall r. 1 <= r < row ->
       forall i. 0 <= i < outer[r] - inner[r] ->
         increasing_column outer inner work r i) /\
    (row < length outer ->
      forall i. idx < i < outer[row] - inner[row] ->
        increasing_column outer inner work row i)

  predicate is_tableau_reading (outer inner: array int) (work: matrix int) =
    is_tableau_reading_suffix outer inner work (length outer) 0

  (* to_word: matrix -> array

     #rows = s = length outer
     width r = outer[r] - inner[r]

      _____________________
  s-1 |_______|___        |
  s-2 |  |________|___    |
   |  |    |__________|___|
   0  |_______|___________|
               0 -> idx -->

      0                                        length = \sum width
     +---------+---------+----------+---------+
     | row s-1 | row s-2 |   ...    |  row 0  |
     +---------+---------+----------+---------+

  *)

  predicate valid_work (outer inner: array int) (w: matrix int) =
    rows w = length outer /\
    (forall r. 0 <= r < length outer ->
               columns w >= outer[r] - inner[r])

  function to_word (outer inner: array int) (w: matrix int) : array int

  function word_length (outer inner: array int) : int =
    sum 0 (length outer) (width outer inner)

  axiom to_word_size:
    forall outer inner w. included inner outer -> valid_work outer inner w ->
    length (to_word outer inner w) = word_length outer inner

  function word_index (outer inner: array int) (row idx: int) : int =
    idx + sum (row + 1) (length outer) (width outer inner)

  axiom to_word_contents:
    forall outer inner w. included inner outer -> valid_work outer inner w ->
    forall r. 0 <= r < length outer ->
    forall i. 0 <= i < width outer inner r ->
    (to_word outer inner w)[word_index outer inner r i] = Matrix.get w r i

  let lemma valid_to_word_index (outer inner: array int) (r i: int)
    requires { included inner outer }
    requires { 0 <= r < length outer }
    requires { 0 <= i < width outer inner r }
    ensures  { 0 <= word_index outer inner r i < word_length outer inner }
  = assert { word_length outer inner                        =
             sum 0 r                    (width outer inner) +
             width outer inner r                            +
             sum (r + 1) (length outer) (width outer inner) }

  (* Yamanouchi condition *)

  predicate is_yam_suffix (w: array int) (len: int) =
    let n = length w in
    0 <= len <= n /\
    (forall i: int. n - len <= i < n -> 0 <= w[i]) /\
    (forall p: int. 0 <= p <= len ->
       forall v1 v2. 0 <= v1 <= v2 -> numeq w v2 (n-p) n <= numeq w v1 (n-p) n)

  predicate is_yam (w: array int) =
    is_yam_suffix w (length w)

  predicate is_of_eval_suffix (eval: array int) (w: array int) (len: int) =
    let n = length w in
    (forall i: int. n - len <= i < n -> 0 <= w[i] < length eval) /\
    (forall v: int. 0 <= v < length eval -> numeq w v (n-len) n <= eval[v])

  predicate is_of_eval (eval: array int) (w: array int) =
    let n = length w in
    (forall i: int. 0 <= i < n -> 0 <= w[i] < length eval) /\
    (forall v: int. 0 <= v < length eval -> numeq w v 0 n = eval[v])

  predicate is_yam_of_eval_suffix (eval: array int) (w: array int) (len: int) =
    is_yam_suffix w len /\
    is_of_eval_suffix eval w len

  predicate is_yam_of_eval (eval: array int) (w: array int) =
    is_yam w /\
    is_of_eval eval w

  (* solution *)

  function suffix_length (outer inner: array int) (row idx: int) : int =
    sum 0 row (width outer inner) +
    if row = length outer then 0 else width outer inner row - idx - 1

  predicate is_solution_suffix
    (outer inner eval: array int) (w: matrix int) (row idx: int) =
    valid_work outer inner w /\
    (let len = suffix_length outer inner row idx in
    is_yam_of_eval_suffix eval (to_word outer inner w) len) /\
    is_tableau_reading_suffix outer inner w row idx

  predicate is_solution (outer inner eval: array int) (w: matrix int) =
    valid_work outer inner w /\
    is_yam_of_eval eval (to_word outer inner w) /\
    is_tableau_reading outer inner w

  lemma sols_pos:
    forall outer inner eval sol.
    included inner outer ->
    is_solution outer inner eval sol ->
    forall r i. 0 <= r < length outer -> 0 <= i < width outer inner r  ->
    0 <= Matrix.get sol r i

  (* solutions are found in lexicographic order *)

  predicate eq_rows (outer inner: array int) (w1 w2: matrix int) (row: int) =
    forall r. 0 <= r < row ->
      forall i. 0 <= i < width outer inner r ->
        Matrix.get w1 r i = Matrix.get w2 r i

  predicate lt_sol (outer inner: array int) (w1 w2: matrix int) =
    (* rows w1 = rows w2 = length outer /\ columns w1 = columns w2 /\ *)
    exists row: int.
      0 <= row < length outer /\ eq_rows outer inner w1 w2 row /\
      exists col. 0 <= col < width outer inner row /\
        (forall i. col < i < width outer inner row ->
          Matrix.get w1 row i = Matrix.get w2 row i) /\
        Matrix.get w1 row col < Matrix.get w2 row col

  lemma frame_lt_sol:
    forall outer inner w1 w2 row idx.
    frame outer inner w1 w2 row idx ->
    0 <= row < length outer ->
    0 <= idx < width outer inner row ->
    Matrix.get w1 row idx < Matrix.get w2 row idx ->
    lt_sol outer inner w1 w2

  predicate eq_sol (outer inner: array int) (w1 w2: matrix int) =
    (* rows w1 = rows w2 = length outer /\ columns w1 = columns w2 /\ *)
    eq_rows outer inner w1 w2 (length outer)

  lemma lt_not_eq:
    forall outer inner: array int, w1 w2: matrix int.
    lt_sol outer inner w1 w2 -> not (eq_sol outer inner w1 w2)

  (* a type to store solutions *)

  type solution

  function m2s (matrix int) : solution
  function s2m solution : matrix int

  axiom m2s2m_def:
    forall m: matrix int. s2m (m2s m) = m

  type solutions = {
    mutable sols: map int solution;
    mutable next: int; (* next slot for a solution *)
  }

  (* s[lo..hi[ is sorted for lt_sol *)
  predicate sorted (outer inner: array int) (s: solutions) (lo hi: int) =
    forall i j: int.
      lo <= i < j < hi ->
      lt_sol outer inner (s2m (Map.get s.sols i)) (s2m (Map.get s.sols j))

  (* a sorted array of solutions contains no duplicate *)
  lemma no_duplicate:
    forall outer inner: array int, s: solutions, lo hi: int.
    sorted outer inner s lo hi ->
    forall i j: int. lo <= i < j < hi ->
      not (eq_sol outer inner (s2m (Map.get s.sols i)) (s2m (Map.get s.sols j)))

  predicate good_solutions (outer inner eval: array int) (s: solutions) =
    0 <= s.next /\
    sorted outer inner s 0 s.next /\
    (forall i. 0 <= i < s.next ->
      is_solution outer inner eval (s2m (Map.get s.sols i))) /\
    (forall w. is_solution outer inner eval w ->
       exists i. 0 <= i < s.next /\
                 eq_sol outer inner w (s2m (Map.get s.sols i)))

end

module ToWord
  use import int.Int
  use import int.MinMax
  use import ref.Refint
  use import array.Array
  use import matrix.Matrix
  use import Sum
  use import Spec

  let ghost to_word (outer inner: array int) (w: matrix int) : array int
    requires { included inner outer }
    requires { valid_work outer inner w }
    ensures  { length result = word_length outer inner }
    ensures  { forall r. 0 <= r < length outer ->
               forall i. 0 <= i < width outer inner r ->
               result[word_index outer inner r i] = Matrix.get w r i }
  =
    let s = length outer in
    let n = ref 0 in
    for r = 0 to s - 1 do invariant { !n = sum 0 r (width outer inner) >= 0 }
      n += outer[r] - inner[r]
    done;
    let a = Array.make !n 0 in
    let start = ref 0 in
    for row = s - 1 downto 0 do
      invariant { !start = sum (row + 1) (length outer) (width outer inner) }
      invariant { forall r. row < r < length outer ->
                  forall i. 0 <= i < width outer inner r ->
                  a[i + sum (r + 1) (length outer) (width outer inner)] =
                  Matrix.get w r i }
      for col = 0 to outer[row] - inner[row] - 1 do
        invariant { forall r. row < r < length outer ->
                    forall i. 0 <= i < width outer inner r ->
                    a[i + sum (r + 1) (length outer) (width outer inner)] =
                    Matrix.get w r i }
        invariant { forall i. 0 <= i < col ->
                    a[i + sum (row + 1) (length outer) (width outer inner)] =
                    Matrix.get w row i }
        a[!start + col] <- Matrix.get w row col
      done;
      start += outer[row] - inner[row]
    done;
    a

end

module LRrule

  use import int.Int
  use import int.MinMax
  use import ref.Refint
  use import array.Array
  use import matrix.Matrix

  use import Sum
  use import int.NumOf
  use import ArraySum
  use import Spec

  val ghost solutions: solutions

  val ghost store_solution (outer inner eval: array int) (w: matrix int)
    : unit
    requires { is_solution outer inner eval w }
    writes   { solutions.sols, solutions.next }
    ensures  { solutions.next = (old solutions.next) + 1 }
    ensures  { solutions.sols =
               Map.set (old solutions.sols) (old solutions.next) (m2s w) }

  let compute_width (outer inner: array int) : array int
    requires { length outer = length inner }
    ensures  { length result = length outer }
    ensures  { forall j. 0 <= j < length outer ->
    	       result[j] = width outer inner j }
  =
    let n = Array.length outer in
    let a = Array.make n 0 in
    for i = 0 to n - 1 do
      invariant { forall j. 0 <= j < i -> a[j] = width outer inner j }
      a[i] <- outer[i] - inner[i]
    done;
    a

  let max_array (a: array int) : int
    ensures  { forall j. 0 <= j < length a -> a[j] <= result }
  =
    let m = ref 0 in
    for i = 0 to Array.length a - 1 do
      invariant { forall j. 0 <= j < i -> a[j] <= !m }
      if a[i] > !m then m := a[i]
    done;
    !m

  let compute_shift (inner: array int) : array int
    ensures  { length result = length inner }
    ensures  { forall j. 0 < j < length inner ->
    	       result[j] = inner[j - 1] - inner[j] }
  =
    let n = Array.length inner in
    let shift = Array.make n 0 in
    for i = 1 to n - 1 do
      invariant { forall j. 0 < j < i -> shift[j] = inner[j-1] - inner[j] }
      shift[i] <- inner[i-1] - inner[i]
    done;
    shift

  (* these lemmas are used only in the program proof, not in the Coq proof
     of equivalence *)

  lemma width_nonneg:
    forall outer inner r. included inner outer ->
    0 <= r < length outer -> 0 <= width outer inner r

  lemma sum_width_nonneg:
    forall outer inner r1 r2. included inner outer ->
    0 <= r1 <= r2 <= length outer -> 0 <= sum r1 r2 (width outer inner)

  predicate valid_cell (outer inner: array int) (row idx: int) =
    0 <= row <= length outer /\
    if row < length outer then -1 <= idx < width outer inner row
    else idx = -1

  (* cell (row, idx) is beyond cell (r, i)
     (row, idx) might be (length outer, 0), but (r, i) is a legal cell *)
  predicate cell_beyond (outer inner: array int) (row idx r i: int) =
    valid_cell outer inner row idx /\
    0 <= r < length outer /\ 0 <= i < width outer inner r /\
    (r < row \/ r = row /\ idx < i)

  lemma cell_beyond_framed:
    forall outer inner work1 work2 row idx r i.
    frame outer inner work1 work2 row idx ->
    cell_beyond outer inner row idx r i ->
    Matrix.get work2 r i = Matrix.get work1 r i

  lemma non_decreasing_row_suffix_framed:
    forall outer inner work1 work2 row idx r start.
    non_decreasing_row_suffix outer inner work1 r start ->
    frame outer inner work1 work2 row idx ->
    cell_beyond outer inner row idx r start ->
    non_decreasing_row_suffix outer inner work2 r start

  lemma increasing_column_framed:
    forall outer inner work1 work2 row idx r i.
    valid_input outer inner ->
    increasing_column outer inner work1 r i ->
    frame outer inner work1 work2 row idx ->
    cell_beyond outer inner row idx r i ->
    increasing_column outer inner work2 r i

  lemma is_tableau_reading_suffix_framed:
    forall outer inner work1 work2 row idx.
    valid_input outer inner ->
    valid_cell outer inner row idx ->
    is_tableau_reading_suffix outer inner work1 row idx ->
    frame outer inner work1 work2 row idx ->
    is_tableau_reading_suffix outer inner work2 row idx

  lemma to_word_suffix_framed:
    forall outer inner work1 work2 row idx.
    valid_input outer inner ->
    valid_cell outer inner row idx ->
    valid_work outer inner work1 -> valid_work outer inner work2 ->
    frame outer inner work1 work2 row idx ->
    forall r i. cell_beyond outer inner row idx r i ->
    let k = i + sum (r + 1) (length outer) (width outer inner) in
    (to_word outer inner work2)[k] = (to_word outer inner work1)[k]

  let lemma decomp_word_index (outer inner: array int) (k: int)
    requires { valid_input outer inner }
    requires { 0 <= k < word_length outer inner }
    ensures  { exists r. exists i. 0 <= r < length outer /\
               0 <= i < width outer inner r /\
               k = word_index outer inner r i }
  =
    let rec lookup (r s: int) =
      requires { 0 <= r < length outer }
      requires { 0 <= s = sum (r + 1) (length outer) (width outer inner) <= k }
      variant  { r }
      ensures  { exists r. exists i. 0 <= r < length outer /\
                 0 <= i < width outer inner r /\
                 k = i + sum (r + 1) (length outer) (width outer inner) }
      let s1 = s + outer[r] - inner[r] in
      if s1 <= k then lookup (r - 1) s1 else
      assert { k = (k - s) + sum (r + 1) (length outer) (width outer inner) }
    in
    lookup (length outer - 1) 0

  let lemma decomp_word_index2
    (outer inner: array int) (work: matrix int) (row idx r i: int)
    requires { valid_input outer inner }
    requires { valid_cell outer inner row idx }
    requires { valid_work outer inner work }
    requires { 0 <= r < length outer }
    requires { 0 <= i < width outer inner r }
    requires { word_length outer inner - suffix_length outer inner row idx
               <= word_index outer inner r i < word_length outer inner }
    ensures  { cell_beyond outer inner row idx r i }
  =
    assert { 0 <= word_length outer inner - suffix_length outer inner row idx };
    assert { 0 <= suffix_length outer inner row idx };
    assert { word_length outer inner =
             sum 0 r                    (width outer inner) +
             width outer inner r                            +
             sum (r + 1) (length outer) (width outer inner) }

  lemma is_yam_suffix_framed:
    forall outer inner work1 work2 row idx.
    valid_input outer inner ->
    valid_cell outer inner row idx ->
    valid_work outer inner work1 -> valid_work outer inner work2 ->
    let len = suffix_length outer inner row idx in
    is_yam_suffix (to_word outer inner work1) len ->
    frame outer inner work1 work2 row idx ->
    is_yam_suffix (to_word outer inner work2) len

  lemma is_of_eval_suffix_framed:
    forall outer inner eval work1 work2 row idx.
    valid_input outer inner ->
    valid_cell outer inner row idx ->
    valid_work outer inner work1 -> valid_work outer inner work2 ->
    let len = suffix_length outer inner row idx in
    is_of_eval_suffix eval (to_word outer inner work1) len ->
    frame outer inner work1 work2 row idx ->
    is_of_eval_suffix eval (to_word outer inner work2) len

  lemma is_yam_of_eval_suffix_framed:
    forall outer inner eval work1 work2 row idx.
    valid_input outer inner ->
    valid_cell outer inner row idx ->
    valid_work outer inner work1 -> valid_work outer inner work2 ->
    let len = suffix_length outer inner row idx in
    is_yam_of_eval_suffix eval (to_word outer inner work1) len ->
    frame outer inner work1 work2 row idx ->
    is_yam_of_eval_suffix eval (to_word outer inner work2) len

  lemma is_solution_suffix_framed:
    forall outer inner eval work1 work2 row idx.
    valid_input outer inner ->
    valid_cell outer inner row idx ->
    valid_work outer inner work1 -> valid_work outer inner work2 ->
    is_solution_suffix outer inner eval work1 row idx ->
    frame outer inner work1 work2 row idx ->
    is_solution_suffix outer inner eval work2 row idx

  lemma solution_suffix_solution:
    forall outer inner eval work.
    valid_input inner outer -> valid_work outer inner work ->
    is_solution_suffix outer inner eval work (length outer) 0 ->
    is_solution        outer inner eval work

  (* move to next row *)
  lemma frame_next_row:
    forall outer inner w1 w2 row.
    0 <= row < length outer ->
    frame outer inner w1 w2 row       (-1)
    <->
    frame outer inner w1 w2 (row + 1) (width outer inner (row+1) - 1)

  lemma solution_suffix_next_row:
    forall outer inner eval work row.
    included inner outer ->
    0 <= row < length outer ->
    is_solution_suffix
      outer inner eval work row     (-1) ->
    is_solution_suffix
      outer inner eval work (row+1) (width outer inner (row+1) - 1)

  (* move to last row *)
  lemma solution_suffix_last_row:
    forall outer inner eval work.
    included inner outer ->
    is_solution_suffix outer inner eval work (length outer - 1) (-1) ->
    is_solution_suffix outer inner eval work (length outer)     0

  lemma is_yam_of_eval_suffix_0:
    forall outer inner eval work.
    included inner outer -> valid_work outer inner work -> is_part eval ->
    is_yam_of_eval_suffix eval (to_word outer inner work) 0

  function andp (p q: int -> bool) : int -> bool = \i. p i /\ q i
  function notp (p  : int -> bool) : int -> bool = \i. not (p i)
  function intv (w: array int) (a b: int) : int -> bool = \i. a <= w[i] < b
  function eq   (w: array int) (v: int) : int -> bool = \i. w[i] = v

  let rec lemma numof_change_exclusion (p1 p2: int -> bool) (a b: int)
    variant { b - a }
    ensures  { numof p1 a b =
               numof (andp p1 p2) a b + numof (andp p1 (notp p2)) a b }
  = if a < b then numof_change_exclusion p1 p2 (a+1) b

  let lemma is_yam_of_eval_length (eval w: array int)
    requires { is_yam_of_eval eval w }
    ensures  { length w = sum_array eval }
  = let k = length eval in
    let n = length w in
    for v = k downto 0 do
      invariant { n = sum v k (\i:int. numeq w i 0 n)
                    + numof (\i: int. 0 <= w[i] < v) 0 n }
      assert { numof (\i: int. 0 <= w[i] < v) 0 n =
               numof (andp (\i: int. 0 <= w[i] < v) (notp (\i. w[i] = v-1))) 0 n +
               numof (andp (\i: int. 0 <= w[i] < v) (\i. w[i] = v-1))  0 n }
      (* numof_change_exclusion (intv w 0 v) (eq w (v-1)) 0 n *)
    done

  lemma solution_length:
    forall outer inner eval w.
    is_solution outer inner eval w ->
    length (to_word outer inner w) = sum_array eval

  (*
     row = current row, in [0 .. length outer[
     idx = current index in row (from left to left),
           in [0 .. outer[row]-inner[row][

   ^  _____________________
   |  |_______|___        |
  row |  |________|___    |
   |  |    |__________|___|
   0  |_______|___________|
               0 -> idx -->
  *)

  let lrrule (outer inner eval: array int) : int =
    requires { valid_input outer inner }
    requires { valid_eval eval }
    requires { sum_array eval = sum_array outer - sum_array inner }
    requires { solutions.next = 0 }
    ensures  { result = solutions.next }
    ensures  { "expl:good solutions" good_solutions outer inner eval solutions }
    let szshape = Array.length outer in (* = Array.length inner *)
    let width = compute_width outer inner in
    let max_width = max_array width in
    let shift = compute_shift inner in
    let szeval = Array.length eval in
    let innev = Array.make szeval 0 in
    let lastinnev = ref 0 in (* only zeros from this index *)
    let work = Matrix.make szshape max_width 0 in
    let rec count_rec (row idx: int) : int =
      requires { valid_cell outer inner row idx }
      requires { "expl:valid_innev"
                 valid_innev outer inner eval innev work row idx !lastinnev }
      requires { sum_array innev = suffix_length outer inner row idx }
      requires { is_solution_suffix outer inner eval work row idx }
      variant  { szshape - row, idx + 1 }
      ensures  { !lastinnev = old !lastinnev }
      ensures  { forall i. 0 <= i < length innev -> innev[i] = (old innev)[i] }
      ensures  { "expl:frame" frame outer inner (old work) work row idx }
      ensures  { result = solutions.next - old solutions.next >= 0 }
      ensures  { forall i. 0 <= i < old solutions.next ->
                 Map.get solutions.sols i = Map.get (old solutions.sols) i }
      ensures  { "expl:only solutions"
                 forall i. old solutions.next <= i < solutions.next ->
                 let w = s2m (Map.get solutions.sols i) in
                 is_solution outer inner eval w /\
                 frame outer inner (old work) w row idx }
      ensures  { "expl:sorted solutions"
                 sorted outer inner
                   solutions (old solutions.next) solutions.next }
      ensures  { forall w. is_solution outer inner eval w ->
                 frame outer inner (old work) w row idx ->
                 exists i. old solutions.next <= i < solutions.next /\
                      eq_sol outer inner w (s2m (Map.get solutions.sols i)) }
      if row = szshape then begin
        (* found a solution *)
        ghost store_solution outer inner eval work;
        1 (* found a solution *)
      end else if idx < 0 then
        (* move from row [row-1] to row [row] *)
        count_rec (row + 1)
	  (abstract (*ensures { result =
            if row + 1 < szshape then width[row + 1] - 1 else 0 }*)
            if row + 1 < szshape then width[row + 1] - 1 else -1 end)
      else begin
        let min = abstract (*ensures { result =
          if row > 0 && idx >= shift[row]
          then Matrix.get work (row - 1) (idx - shift[row]) + 1 else 0 }*)
          if row > 0 && idx >= shift[row]
          then Matrix.get work (row - 1) (idx - shift[row]) + 1 else 0 end in
        let max = abstract (*ensures { result =
          if idx = width[row] - 1 then !lastinnev
          else MinMax.min !lastinnev (Matrix.get work row (idx + 1)) }*)
          if idx = width[row] - 1 then !lastinnev
          else MinMax.min !lastinnev (Matrix.get work row (idx + 1)) end in
        let sum = ref 0 in
        'Init:
        for v = min to max do
          invariant { !lastinnev = at !lastinnev 'Init }
          invariant { forall i. 0 <= i < length innev ->
                      innev[i] = (at innev 'Init)[i] }
          invariant { "expl:frame"
                      frame outer inner (at work 'Init) work row idx }
          invariant { "expl:valid_innev"
                  valid_innev outer inner eval innev work row idx !lastinnev }
          invariant { !sum = solutions.next - at solutions.next 'Init >= 0 }
          invariant { forall i. 0 <= i < at solutions.next 'Init ->
                Map.get solutions.sols i = Map.get (at solutions.sols 'Init) i }
          invariant { is_tableau_reading_suffix outer inner work row idx }
          invariant { "expl:only solutions"
                      forall i. at solutions.next 'Init <= i < solutions.next ->
                      let w = s2m (Map.get solutions.sols i) in
                      is_solution outer inner eval w /\
                      frame outer inner (at work 'Init) w row idx /\
                      min <= Matrix.get w row idx < v }
          invariant { "expl:sorted solutions"
                      sorted outer inner
                        solutions (at solutions.next 'Init) solutions.next }
          invariant { "expl: all solutions"
                      forall w. is_solution outer inner eval w ->
                      frame outer inner (at work 'Init) w row idx ->
                      min <= Matrix.get w row idx < v ->
                  exists i. at solutions.next 'Init <= i < solutions.next /\
                  frame outer inner w (s2m (Map.get solutions.sols i)) row idx }
          'L:
          if abstract (*ensures { result <->
            innev[v] < eval[v] && (v = 0 || innev[v-1] > innev[v]) }*)
            innev[v] < eval[v] && (v = 0 || innev[v-1] > innev[v])
          end then begin
            innev[v] <- innev[v] + 1;
            if v = !lastinnev then lastinnev += 1;
            assert { 0 <= v < !lastinnev };
            Matrix.set work row idx v;
            sum += count_rec row (idx - 1);
            innev[v] <- innev[v] - 1;
            assert { eq_array innev (at innev 'L) };
           if abstract (*ensures { result <->
             !lastinnev = v+1 && innev[v] = 0 }*)
             !lastinnev = v+1 && innev[v] = 0
           end then lastinnev -= 1
          end
        done;
        !sum
      end
    in
    count_rec 0 (width[0] - 1)

end

(*
Local Variables:
compile-command: "why3 ide lrrule"
End:
*)
