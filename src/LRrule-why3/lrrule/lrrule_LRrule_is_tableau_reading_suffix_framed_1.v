(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.MinMax.
Require int.NumOf.
Require map.Map.

(* Why3 assumption *)
Definition unit := unit.

Axiom qtmark : Type.
Parameter qtmark_WhyType : WhyType qtmark.
Existing Instance qtmark_WhyType.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | mk_ref : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Implicit Arguments mk_ref [[a]].

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:(ref a)): a :=
  match v with
  | (mk_ref x) => x
  end.

(* Why3 assumption *)
Inductive array (a:Type) :=
  | mk_array : Z -> (map.Map.map Z a) -> array a.
Axiom array_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.
Implicit Arguments mk_array [[a]].

(* Why3 assumption *)
Definition elts {a:Type} {a_WT:WhyType a} (v:(array a)): (map.Map.map Z a) :=
  match v with
  | (mk_array x x1) => x1
  end.

(* Why3 assumption *)
Definition length {a:Type} {a_WT:WhyType a} (v:(array a)): Z :=
  match v with
  | (mk_array x x1) => x
  end.

(* Why3 assumption *)
Definition get {a:Type} {a_WT:WhyType a} (a1:(array a)) (i:Z): a :=
  (map.Map.get (elts a1) i).

(* Why3 assumption *)
Definition set {a:Type} {a_WT:WhyType a} (a1:(array a)) (i:Z) (v:a): (array
  a) := (mk_array (length a1) (map.Map.set (elts a1) i v)).

(* Why3 assumption *)
Definition make {a:Type} {a_WT:WhyType a} (n:Z) (v:a): (array a) :=
  (mk_array n (map.Map.const v: (map.Map.map Z a))).

(* Why3 assumption *)
Inductive matrix
  (a:Type) :=
  | mk_matrix : Z -> Z -> (map.Map.map Z (map.Map.map Z a)) -> matrix a.
Axiom matrix_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (matrix a).
Existing Instance matrix_WhyType.
Implicit Arguments mk_matrix [[a]].

(* Why3 assumption *)
Definition elts1 {a:Type} {a_WT:WhyType a} (v:(matrix a)): (map.Map.map Z
  (map.Map.map Z a)) := match v with
  | (mk_matrix x x1 x2) => x2
  end.

(* Why3 assumption *)
Definition columns {a:Type} {a_WT:WhyType a} (v:(matrix a)): Z :=
  match v with
  | (mk_matrix x x1 x2) => x1
  end.

(* Why3 assumption *)
Definition rows {a:Type} {a_WT:WhyType a} (v:(matrix a)): Z :=
  match v with
  | (mk_matrix x x1 x2) => x
  end.

(* Why3 assumption *)
Definition get1 {a:Type} {a_WT:WhyType a} (a1:(matrix a)) (r:Z) (c:Z): a :=
  (map.Map.get (map.Map.get (elts1 a1) r) c).

(* Why3 assumption *)
Definition set1 {a:Type} {a_WT:WhyType a} (a1:(matrix a)) (r:Z) (c:Z)
  (v:a): (matrix a) := (mk_matrix (rows a1) (columns a1)
  (map.Map.set (elts1 a1) r (map.Map.set (map.Map.get (elts1 a1) r) c v))).

(* Why3 assumption *)
Definition valid_index {a:Type} {a_WT:WhyType a} (a1:(matrix a)) (r:Z)
  (c:Z): Prop := ((0%Z <= r)%Z /\ (r < (rows a1))%Z) /\ ((0%Z <= c)%Z /\
  (c < (columns a1))%Z).

(* Why3 assumption *)
Definition make1 {a:Type} {a_WT:WhyType a} (r:Z) (c:Z) (v:a): (matrix a) :=
  (mk_matrix r c (map.Map.const (map.Map.const v: (map.Map.map Z
  a)): (map.Map.map Z (map.Map.map Z a)))).

Parameter sum: Z -> Z -> (Z -> Z) -> Z.

Axiom sum_def1 : forall (f:(Z -> Z)) (a:Z) (b:Z), (b <= a)%Z -> ((sum a b
  f) = 0%Z).

Axiom sum_def2 : forall (f:(Z -> Z)) (a:Z) (b:Z), (a < b)%Z -> ((sum a b
  f) = ((sum a (b - 1%Z)%Z f) + (f (b - 1%Z)%Z))%Z).

Axiom sum_left : forall (f:(Z -> Z)) (a:Z) (b:Z), (a < b)%Z -> ((sum a b
  f) = ((f a) + (sum (a + 1%Z)%Z b f))%Z).

Axiom sum_ext : forall (f:(Z -> Z)) (g:(Z -> Z)) (a:Z) (b:Z), (forall (i:Z),
  ((a <= i)%Z /\ (i < b)%Z) -> ((f i) = (g i))) -> ((sum a b f) = (sum a b
  g)).

Axiom sum_le : forall (f:(Z -> Z)) (g:(Z -> Z)) (a:Z) (b:Z), (forall (i:Z),
  ((a <= i)%Z /\ (i < b)%Z) -> ((f i) <= (g i))%Z) -> ((sum a b f) <= (sum a
  b g))%Z.

Axiom sum_nonneg : forall (f:(Z -> Z)) (a:Z) (b:Z), (forall (i:Z),
  ((a <= i)%Z /\ (i < b)%Z) -> (0%Z <= (f i))%Z) -> (0%Z <= (sum a b f))%Z.

Axiom sum_decomp : forall (f:(Z -> Z)) (a:Z) (b:Z) (c:Z), ((a <= b)%Z /\
  (b <= c)%Z) -> ((sum a c f) = ((sum a b f) + (sum b c f))%Z).

(* Why3 assumption *)
Definition sum_sub_array (a:(array Z)) (lo:Z) (hi:Z): Z := (sum lo hi
  (fun (i:Z) => (get a i))).

(* Why3 assumption *)
Definition sum_array (a:(array Z)): Z := (sum_sub_array a 0%Z (length a)).

Axiom sum_sub_array_shift : forall (a:(array Z)) (b:(array Z)) (lo:Z) (hi:Z),
  (((0%Z <= (length a))%Z /\ (0%Z <= (length b))%Z) /\
  ((((length a) + 1%Z)%Z = (length b)) /\ forall (i:Z), ((lo <= i)%Z /\
  (i < hi)%Z) -> ((get a i) = (get b (i + 1%Z)%Z)))) -> ((sum_sub_array a lo
  hi) = (sum_sub_array b (lo + 1%Z)%Z (hi + 1%Z)%Z)).

Axiom sum_array_sub : forall (a:(array Z)) (b:(array Z)) (lo:Z) (hi:Z),
  (((0%Z <= (length a))%Z /\ (0%Z <= (length b))%Z) /\
  ((length a) = (length b))) -> ((sum lo hi (fun (i:Z) => ((get b i) - (get a
  i))%Z)) = ((sum_sub_array b lo hi) - (sum_sub_array a lo hi))%Z).

(* Why3 assumption *)
Definition is_part (shape:(array Z)): Prop := (1%Z <= (length shape))%Z /\
  ((forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ ((i <= j)%Z /\
  (j < (length shape))%Z)) -> ((get shape j) <= (get shape i))%Z) /\
  (0%Z <= (get shape ((length shape) - 1%Z)%Z))%Z).

Axiom is_part_nonneg : forall (sh:(array Z)), (is_part sh) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (length sh))%Z) -> (0%Z <= (get sh i))%Z.

(* Why3 assumption *)
Definition included (inner:(array Z)) (outer:(array Z)): Prop :=
  ((length inner) = (length outer)) /\ forall (i:Z), ((0%Z <= i)%Z /\
  (i < (length outer))%Z) -> ((get inner i) <= (get outer i))%Z.

Axiom sum_le_eq : forall (f:(Z -> Z)) (g:(Z -> Z)) (a:Z) (b:Z),
  ((forall (i:Z), ((a <= i)%Z /\ (i < b)%Z) -> ((f i) <= (g i))%Z) /\ ((sum a
  b f) = (sum a b g))) -> forall (i:Z), ((a <= i)%Z /\ (i < b)%Z) -> ((f
  i) = (g i)).

Axiom included_parts_eq : forall (innev:(array Z)) (eval:(array Z)),
  (included innev eval) -> (((sum_array innev) = (sum_array eval)) ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < (length innev))%Z) -> ((get innev
  i) = (get eval i))).

Parameter fc: (array Z) -> Z -> (Z -> bool).

Axiom fc_def : forall (a:(array Z)) (v:Z) (i:Z), (((fc a v) i) = true) <->
  ((get a i) = v).

(* Why3 assumption *)
Definition numeq (a:(array Z)) (v:Z) (lo:Z) (hi:Z): Z :=
  (int.NumOf.numof (fc a v) lo hi).

Axiom numeq_shift : forall (a1:(array Z)) (a2:(array Z)) (v:Z) (lo:Z) (hi:Z),
  (((0%Z <= (length a1))%Z /\ (0%Z <= (length a2))%Z) /\ forall (i:Z),
  ((lo <= i)%Z /\ (i < hi)%Z) -> ((get a1 i) = (get a2 (i + 1%Z)%Z))) ->
  ((numeq a1 v lo hi) = (numeq a2 v (lo + 1%Z)%Z (hi + 1%Z)%Z)).

Axiom numeq0 : forall (w:(array Z)) (k:Z), (forall (i:Z), ((0%Z <= i)%Z /\
  (i < (length w))%Z) -> ((get w i) < k)%Z) -> ((numeq w k 0%Z
  (length w)) = 0%Z).

(* Why3 assumption *)
Definition valid_input (outer:(array Z)) (inner:(array Z)): Prop := (included
  inner outer) /\ ((is_part inner) /\ (is_part outer)).

(* Why3 assumption *)
Definition eq_prefix (s1:(array Z)) (s2:(array Z)) (i:Z): Prop :=
  forall (k:Z), ((0%Z <= k)%Z /\ (k < i)%Z) -> ((get s1 k) = (get s2 k)).

(* Why3 assumption *)
Definition eq_array (s1:(array Z)) (s2:(array Z)): Prop :=
  ((length s1) = (length s2)) /\ (eq_prefix s1 s2 (length s1)).

(* Why3 assumption *)
Definition valid_eval (eval:(array Z)): Prop := (1%Z <= (length eval))%Z /\
  ((is_part eval) /\ ((get eval ((length eval) - 1%Z)%Z) = 0%Z)).

(* Why3 assumption *)
Definition valid_innev (outer:(array Z)) (inner:(array Z)) (eval:(array Z))
  (innev:(array Z)) (work:(matrix Z)) (row:Z) (idx:Z) (lastinnev:Z): Prop :=
  ((0%Z <= lastinnev)%Z /\ (lastinnev < (length eval))%Z) /\ ((is_part
  innev) /\ ((included innev eval) /\ ((forall (r:Z), ((0%Z <= r)%Z /\
  (r < row)%Z) -> forall (i:Z), ((0%Z <= i)%Z /\ (i < ((get outer
  r) - (get inner r))%Z)%Z) -> ((0%Z <= (get1 work r i))%Z /\ ((get1 work r
  i) < lastinnev)%Z)) /\ (((row < (length outer))%Z -> forall (i:Z),
  ((idx < i)%Z /\ (i < ((get outer row) - (get inner row))%Z)%Z) ->
  ((0%Z <= (get1 work row i))%Z /\ ((get1 work row i) < lastinnev)%Z)) /\
  (((lastinnev = 0%Z) \/ (0%Z < (get innev (lastinnev - 1%Z)%Z))%Z) /\
  forall (i:Z), ((lastinnev <= i)%Z /\ (i < (length innev))%Z) -> ((get innev
  i) = 0%Z)))))).

Axiom is_part_eq : forall (a1:(array Z)) (a2:(array Z)), (is_part a1) ->
  ((eq_array a1 a2) -> (is_part a2)).

(* Why3 assumption *)
Definition width (outer:(array Z)) (inner:(array Z)): (Z -> Z) :=
  fun (r:Z) => ((get outer r) - (get inner r))%Z.

(* Why3 assumption *)
Definition frame (outer:(array Z)) (inner:(array Z)) (w1:(matrix Z))
  (w2:(matrix Z)) (row:Z) (idx:Z): Prop := (forall (r:Z), ((0%Z <= r)%Z /\
  (r < row)%Z) -> forall (i:Z), ((0%Z <= i)%Z /\ (i < ((width outer inner)
  r))%Z) -> ((get1 w2 r i) = (get1 w1 r i))) /\ ((row < (length outer))%Z ->
  forall (i:Z), ((idx < i)%Z /\ (i < ((width outer inner) row))%Z) ->
  ((get1 w2 row i) = (get1 w1 row i))).

Axiom valid_innev_framed : forall (outer:(array Z)) (inner:(array Z))
  (eval:(array Z)) (innev:(array Z)) (work1:(matrix Z)) (work2:(matrix Z))
  (row:Z) (idx:Z) (lastinnev:Z), (valid_innev outer inner eval innev work1
  row idx lastinnev) -> ((frame outer inner work1 work2 row idx) ->
  (valid_innev outer inner eval innev work2 row idx lastinnev)).

Axiom frame_weakening : forall (outer:(array Z)) (inner:(array Z))
  (work1:(matrix Z)) (work2:(matrix Z)) (row:Z) (idx:Z), (frame outer inner
  work1 work2 row (idx - 1%Z)%Z) -> (frame outer inner work1 work2 row idx).

Axiom frame_trans : forall (outer:(array Z)) (inner:(array Z)) (work1:(matrix
  Z)) (work2:(matrix Z)) (work3:(matrix Z)) (row:Z) (idx:Z), (frame outer
  inner work1 work2 row idx) -> ((frame outer inner work2 work3 row idx) ->
  (frame outer inner work1 work3 row idx)).

(* Why3 assumption *)
Definition non_decreasing_row_suffix (outer:(array Z)) (inner:(array Z))
  (work:(matrix Z)) (r:Z) (start:Z): Prop := forall (i1:Z) (i2:Z),
  ((start <= i1)%Z /\ ((i1 <= i2)%Z /\ (i2 < ((width outer inner) r))%Z)) ->
  ((get1 work r i1) <= (get1 work r i2))%Z.

(* Why3 assumption *)
Definition increasing_column (outer:(array Z)) (inner:(array Z))
  (work:(matrix Z)) (r:Z) (i:Z): Prop := ((0%Z < r)%Z /\ (((get inner
  (r - 1%Z)%Z) - (get inner r))%Z <= i)%Z) -> ((get1 work (r - 1%Z)%Z
  (i - ((get inner (r - 1%Z)%Z) - (get inner r))%Z)%Z) < (get1 work r i))%Z.

(* Why3 assumption *)
Definition is_tableau_reading_suffix (outer:(array Z)) (inner:(array Z))
  (work:(matrix Z)) (row:Z) (idx:Z): Prop := (forall (r:Z), ((0%Z <= r)%Z /\
  (r < row)%Z) -> (non_decreasing_row_suffix outer inner work r 0%Z)) /\
  (((row < (length outer))%Z -> (non_decreasing_row_suffix outer inner work
  row (idx + 1%Z)%Z)) /\ ((forall (r:Z), ((1%Z <= r)%Z /\ (r < row)%Z) ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < ((get outer r) - (get inner
  r))%Z)%Z) -> (increasing_column outer inner work r i)) /\
  ((row < (length outer))%Z -> forall (i:Z), ((idx < i)%Z /\ (i < ((get outer
  row) - (get inner row))%Z)%Z) -> (increasing_column outer inner work row
  i)))).

(* Why3 assumption *)
Definition is_tableau_reading (outer:(array Z)) (inner:(array Z))
  (work:(matrix Z)): Prop := (is_tableau_reading_suffix outer inner work
  (length outer) 0%Z).

(* Why3 assumption *)
Definition valid_work (outer:(array Z)) (inner:(array Z)) (w:(matrix
  Z)): Prop := ((rows w) = (length outer)) /\ forall (r:Z), ((0%Z <= r)%Z /\
  (r < (length outer))%Z) -> (((get outer r) - (get inner
  r))%Z <= (columns w))%Z.

Parameter to_word: (array Z) -> (array Z) -> (matrix Z) -> (array Z).

Axiom to_word_size : forall (outer:(array Z)) (inner:(array Z)) (w:(matrix
  Z)), (included inner outer) -> ((valid_work outer inner w) ->
  ((length (to_word outer inner w)) = (sum 0%Z (length outer) (width outer
  inner)))).

Axiom to_word_contents : forall (outer:(array Z)) (inner:(array Z))
  (w:(matrix Z)), (included inner outer) -> ((valid_work outer inner w) ->
  forall (r:Z), ((0%Z <= r)%Z /\ (r < (length outer))%Z) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < ((width outer inner) r))%Z) -> ((get (to_word outer
  inner w) (i + (sum (r + 1%Z)%Z (length outer) (width outer
  inner)))%Z) = (get1 w r i))).

Axiom valid_to_word_index : forall (outer:(array Z)) (inner:(array Z)) (r:Z)
  (i:Z), (((0%Z <= (length outer))%Z /\ (0%Z <= (length inner))%Z) /\
  ((included inner outer) /\ (((0%Z <= r)%Z /\ (r < (length outer))%Z) /\
  ((0%Z <= i)%Z /\ (i < ((width outer inner) r))%Z)))) ->
  ((0%Z <= (i + (sum (r + 1%Z)%Z (length outer) (width outer inner)))%Z)%Z /\
  ((i + (sum (r + 1%Z)%Z (length outer) (width outer inner)))%Z < (sum 0%Z
  (length outer) (width outer inner)))%Z).

(* Why3 assumption *)
Definition is_yam_suffix (w:(array Z)) (len:Z): Prop := let n :=
  (length w) in (((0%Z <= len)%Z /\ (len <= n)%Z) /\ ((forall (i:Z),
  (((n - len)%Z <= i)%Z /\ (i < n)%Z) -> (0%Z <= (get w i))%Z) /\
  forall (p:Z), ((0%Z <= p)%Z /\ (p <= len)%Z) -> forall (v1:Z) (v2:Z),
  ((0%Z <= v1)%Z /\ (v1 <= v2)%Z) -> ((numeq w v2 (n - p)%Z n) <= (numeq w v1
  (n - p)%Z n))%Z)).

(* Why3 assumption *)
Definition is_yam (w:(array Z)): Prop := (is_yam_suffix w (length w)).

(* Why3 assumption *)
Definition is_of_eval_suffix (eval:(array Z)) (w:(array Z)) (len:Z): Prop :=
  let n := (length w) in ((forall (i:Z), (((n - len)%Z <= i)%Z /\
  (i < n)%Z) -> ((0%Z <= (get w i))%Z /\ ((get w i) < (length eval))%Z)) /\
  forall (v:Z), ((0%Z <= v)%Z /\ (v < (length eval))%Z) -> ((numeq w v
  (n - len)%Z n) = (get eval v))).

(* Why3 assumption *)
Definition is_of_eval (eval:(array Z)) (w:(array Z)): Prop :=
  (is_of_eval_suffix eval w (length w)).

(* Why3 assumption *)
Definition is_yam_of_eval_suffix (eval:(array Z)) (w:(array Z))
  (len:Z): Prop := (is_yam_suffix w len) /\ (is_of_eval_suffix eval w len).

(* Why3 assumption *)
Definition is_yam_of_eval (eval:(array Z)) (w:(array Z)): Prop := (is_yam
  w) /\ (is_of_eval eval w).

Axiom is_yam_of_eval_length : forall (eval:(array Z)) (w:(array Z)),
  (is_yam_of_eval eval w) -> ((length w) = (sum_array eval)).

(* Why3 assumption *)
Definition is_solution_suffix (outer:(array Z)) (inner:(array Z))
  (eval:(array Z)) (w:(matrix Z)) (row:Z) (idx:Z): Prop := (valid_work outer
  inner w) /\ ((((row = (length outer)) -> (is_yam_of_eval_suffix eval
  (to_word outer inner w) ((sum 0%Z row (width outer inner)) + 0%Z)%Z)) /\
  ((~ (row = (length outer))) -> (is_yam_of_eval_suffix eval (to_word outer
  inner w) ((sum 0%Z row (width outer inner)) + ((((width outer inner)
  row) - idx)%Z - 1%Z)%Z)%Z))) /\ (is_tableau_reading_suffix outer inner w
  row idx)).

(* Why3 assumption *)
Definition is_solution (outer:(array Z)) (inner:(array Z)) (eval:(array Z))
  (w:(matrix Z)): Prop := (valid_work outer inner w) /\ ((is_yam_of_eval eval
  (to_word outer inner w)) /\ (is_tableau_reading outer inner w)).

Axiom sols_pos : forall (outer:(array Z)) (inner:(array Z)) (eval:(array Z))
  (sol:(matrix Z)), (included inner outer) -> ((is_solution outer inner eval
  sol) -> forall (r:Z) (i:Z), ((0%Z <= r)%Z /\ (r < (length outer))%Z) ->
  (((0%Z <= i)%Z /\ (i < ((width outer inner) r))%Z) -> (0%Z <= (get1 sol r
  i))%Z)).

Axiom solution_length : forall (outer:(array Z)) (inner:(array Z))
  (eval:(array Z)) (w:(matrix Z)), (is_solution outer inner eval w) ->
  ((length (to_word outer inner w)) = (sum_array eval)).

(* Why3 assumption *)
Definition eq_rows (outer:(array Z)) (inner:(array Z)) (w1:(matrix Z))
  (w2:(matrix Z)) (row:Z): Prop := forall (r:Z), ((0%Z <= r)%Z /\
  (r < row)%Z) -> forall (i:Z), ((0%Z <= i)%Z /\ (i < ((width outer inner)
  r))%Z) -> ((get1 w1 r i) = (get1 w2 r i)).

(* Why3 assumption *)
Definition lt_sol (outer:(array Z)) (inner:(array Z)) (w1:(matrix Z))
  (w2:(matrix Z)): Prop := exists row:Z, ((0%Z <= row)%Z /\
  (row < (length outer))%Z) /\ ((eq_rows outer inner w1 w2 row) /\
  exists col:Z, ((0%Z <= col)%Z /\ (col < ((width outer inner) row))%Z) /\
  ((forall (i:Z), ((col < i)%Z /\ (i < ((width outer inner) row))%Z) ->
  ((get1 w1 row i) = (get1 w2 row i))) /\ ((get1 w1 row col) < (get1 w2 row
  col))%Z)).

Axiom frame_lt_sol : forall (outer:(array Z)) (inner:(array Z)) (w1:(matrix
  Z)) (w2:(matrix Z)) (row:Z) (idx:Z), (frame outer inner w1 w2 row idx) ->
  (((0%Z <= row)%Z /\ (row < (length outer))%Z) -> (((0%Z <= idx)%Z /\
  (idx < ((width outer inner) row))%Z) -> (((get1 w1 row idx) < (get1 w2 row
  idx))%Z -> (lt_sol outer inner w1 w2)))).

(* Why3 assumption *)
Definition eq_sol (outer:(array Z)) (inner:(array Z)) (w1:(matrix Z))
  (w2:(matrix Z)): Prop := (eq_rows outer inner w1 w2 (length outer)).

Axiom lt_not_eq : forall (outer:(array Z)) (inner:(array Z)) (w1:(matrix Z))
  (w2:(matrix Z)), (lt_sol outer inner w1 w2) -> ~ (eq_sol outer inner w1
  w2).

Axiom solution : Type.
Parameter solution_WhyType : WhyType solution.
Existing Instance solution_WhyType.

Parameter m2s: (matrix Z) -> solution.

Parameter s2m: solution -> (matrix Z).

Axiom m2s2m_def : forall (m:(matrix Z)), ((s2m (m2s m)) = m).

(* Why3 assumption *)
Inductive solutions :=
  | mk_solutions : (map.Map.map Z solution) -> Z -> solutions.
Axiom solutions_WhyType : WhyType solutions.
Existing Instance solutions_WhyType.

(* Why3 assumption *)
Definition next (v:solutions): Z :=
  match v with
  | (mk_solutions x x1) => x1
  end.

(* Why3 assumption *)
Definition sols (v:solutions): (map.Map.map Z solution) :=
  match v with
  | (mk_solutions x x1) => x
  end.

(* Why3 assumption *)
Definition sorted (outer:(array Z)) (inner:(array Z)) (s:solutions) (lo:Z)
  (hi:Z): Prop := forall (i:Z) (j:Z), ((lo <= i)%Z /\ ((i < j)%Z /\
  (j < hi)%Z)) -> (lt_sol outer inner (s2m (map.Map.get (sols s) i))
  (s2m (map.Map.get (sols s) j))).

Axiom no_duplicate : forall (outer:(array Z)) (inner:(array Z)) (s:solutions)
  (lo:Z) (hi:Z), (sorted outer inner s lo hi) -> forall (i:Z) (j:Z),
  ((lo <= i)%Z /\ ((i < j)%Z /\ (j < hi)%Z)) -> ~ (eq_sol outer inner
  (s2m (map.Map.get (sols s) i)) (s2m (map.Map.get (sols s) j))).

(* Why3 assumption *)
Definition good_solutions (outer:(array Z)) (inner:(array Z)) (eval:(array
  Z)) (s:solutions): Prop := (0%Z <= (next s))%Z /\ ((sorted outer inner s
  0%Z (next s)) /\ ((forall (i:Z), ((0%Z <= i)%Z /\ (i < (next s))%Z) ->
  (is_solution outer inner eval (s2m (map.Map.get (sols s) i)))) /\
  forall (w:(matrix Z)), (is_solution outer inner eval w) -> exists i:Z,
  ((0%Z <= i)%Z /\ (i < (next s))%Z) /\ (eq_sol outer inner w
  (s2m (map.Map.get (sols s) i))))).

(* Why3 assumption *)
Definition cell_beyond (outer:(array Z)) (inner:(array Z)) (row:Z) (idx:Z)
  (r:Z) (i:Z): Prop := ((0%Z <= row)%Z /\ (row <= (length outer))%Z) /\
  ((((row < (length outer))%Z -> (((-1%Z)%Z <= idx)%Z /\ (idx < ((width outer
  inner) row))%Z)) /\ ((~ (row < (length outer))%Z) -> (idx = 0%Z))) /\
  (((0%Z <= r)%Z /\ (r < (length outer))%Z) /\ (((0%Z <= i)%Z /\
  (i < ((width outer inner) r))%Z) /\ ((r < row)%Z \/ ((r = row) /\
  (idx < i)%Z))))).

Axiom cell_beyond_framed : forall (outer:(array Z)) (inner:(array Z))
  (work1:(matrix Z)) (work2:(matrix Z)) (row:Z) (idx:Z) (r:Z) (i:Z), (frame
  outer inner work1 work2 row idx) -> ((cell_beyond outer inner row idx r
  i) -> ((get1 work2 r i) = (get1 work1 r i))).

Axiom non_decreasing_row_suffix_framed : forall (outer:(array Z))
  (inner:(array Z)) (work1:(matrix Z)) (work2:(matrix Z)) (row:Z) (idx:Z)
  (r:Z) (start:Z), (non_decreasing_row_suffix outer inner work1 r start) ->
  ((frame outer inner work1 work2 row idx) -> ((cell_beyond outer inner row
  idx r start) -> (non_decreasing_row_suffix outer inner work2 r start))).

Axiom increasing_column_framed : forall (outer:(array Z)) (inner:(array Z))
  (work1:(matrix Z)) (work2:(matrix Z)) (row:Z) (idx:Z) (r:Z) (i:Z),
  (valid_input outer inner) -> ((increasing_column outer inner work1 r i) ->
  ((frame outer inner work1 work2 row idx) -> ((cell_beyond outer inner row
  idx r i) -> (increasing_column outer inner work2 r i)))).

Parameter outer: (array Z).

Parameter inner: (array Z).

Parameter work1: (matrix Z).

Parameter work2: (matrix Z).

Parameter row: Z.

Parameter idx: Z.

Axiom H : (valid_input outer inner).

Axiom H1 : (0%Z <= row)%Z.

Axiom H2 : (row <= (length outer))%Z.

Axiom H3 : (row < (length outer))%Z -> ((-1%Z)%Z <= idx)%Z.

Axiom H4 : (row < (length outer))%Z -> (idx < ((width outer inner) row))%Z.

Axiom H5 : (~ (row < (length outer))%Z) -> (idx = 0%Z).

Axiom H6 : (is_tableau_reading_suffix outer inner work1 row idx).

Axiom H7 : (frame outer inner work1 work2 row idx).

(* Why3 goal *)
Theorem is_tableau_reading_suffix_framed : (row < (length outer))%Z ->
  forall (i:Z), ((idx < i)%Z /\ (i < ((get outer row) - (get inner
  row))%Z)%Z) -> (increasing_column outer inner work2 row i).
(* Why3 intros h1 i (h2,h3). *)
intros h1 i (h2,h3).
apply increasing_column_framed with work1 row idx; auto.
exact H.
destruct H6.
intuition.
exact H7.
red; intuition.
exact H1.
apply H3. exact h1.
unfold width. omega.
exact H1.
generalize (H3 h1); intro; omega.
Qed.

