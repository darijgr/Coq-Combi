(* This file is generated by Why3's coq-ssreflect driver *)
(* Beware! Only edit allowed sections below    *)

Require Import ssreflect ssrbool ssrfun ssrnat seq eqtype ssrint.
Require Import ssrint ssrwhy3.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Require Import ssralg ssrnum.
Import GRing.Theory Num.Theory.
Local Open Scope ring_scope.

(* Why3 assumption *)
Definition unit := unit.

Axiom qtmark : Type.

Parameter set: forall {a: why3Type} {b: why3Type}, (a -> b)%type -> a -> b ->
  (a -> b)%type.

Axiom Select_eq : forall {a: why3Type} {b: why3Type},
  forall (m:(a -> b)%type), forall (a1:a) (a2:a), forall (b1:b), (a1 = a2) ->
  (((set m a1 b1) a2) = b1).

Axiom Select_neq : forall {a: why3Type} {b: why3Type},
  forall (m:(a -> b)%type), forall (a1:a) (a2:a), forall (b1:b),
  (~ (a1 = a2)) -> (((set m a1 b1) a2) = (m a2)).

(* Why3 assumption *)
Definition valid_index {a: why3Type} (a1:(matrix a)) (r:int) (c:int): Prop :=
  ((0%:Z <= r)%R /\ (r < (nrows a1 : int))%R) /\ ((0%:Z <= c)%R /\
  (c < (ncols a1 : int))%R).

Parameter sum: int -> int -> (int -> int) -> int.

Axiom sum_def1 : forall (f:(int -> int)) (a:int) (b:int), (b <= a)%R ->
  ((sum a b f) = 0%:Z).

Axiom sum_def2 : forall (f:(int -> int)) (a:int) (b:int), (a < b)%R ->
  ((sum a b f) = ((sum a (b - 1%:Z)%R f) + (f (b - 1%:Z)%R))%R).

Axiom sum_left : forall (f:(int -> int)) (a:int) (b:int), (a < b)%R ->
  ((sum a b f) = ((f a) + (sum (a + 1%:Z)%R b f))%R).

Axiom sum_ext : forall (f:(int -> int)) (g:(int -> int)) (a:int) (b:int),
  (forall (i:int), ((a <= i)%R /\ (i < b)%R) -> ((f i) = (g i))) -> ((sum a b
  f) = (sum a b g)).

Axiom sum_le : forall (f:(int -> int)) (g:(int -> int)) (a:int) (b:int),
  (forall (i:int), ((a <= i)%R /\ (i < b)%R) -> ((f i) <= (g i))%R) ->
  ((sum a b f) <= (sum a b g))%R.

Axiom sum_nonneg : forall (f:(int -> int)) (a:int) (b:int), (forall (i:int),
  ((a <= i)%R /\ (i < b)%R) -> (0%:Z <= (f i))%R) -> (0%:Z <= (sum a b f))%R.

Axiom sum_decomp : forall (f:(int -> int)) (a:int) (b:int) (c:int),
  ((a <= b)%R /\ (b <= c)%R) -> ((sum a c f) = ((sum a b f) + (sum b c
  f))%R).

(* Why3 assumption *)
Definition sum_sub_array (a:(array int)) (lo:int) (hi:int): int := (sum lo hi
  (fun (i:int) => (get a i))).

(* Why3 assumption *)
Definition sum_array (a:(array int)): int := (sum_sub_array a 0%:Z
  (size a : int)).

Axiom sum_sub_array_shift : forall (a:(array int)) (b:(array int)) (lo:int)
  (hi:int), (((0%:Z <= (size a : int))%R /\ (0%:Z <= (size b : int))%R) /\
  ((((size a : int) + 1%:Z)%R = (size b : int)) /\ forall (i:int),
  ((lo <= i)%R /\ (i < hi)%R) -> ((get a i) = (get b (i + 1%:Z)%R)))) ->
  ((sum_sub_array a lo hi) = (sum_sub_array b (lo + 1%:Z)%R (hi + 1%:Z)%R)).

Axiom sum_array_sub : forall (a:(array int)) (b:(array int)) (lo:int)
  (hi:int), (((0%:Z <= (size a : int))%R /\ (0%:Z <= (size b : int))%R) /\
  ((size a : int) = (size b : int))) -> ((sum lo hi (fun (i:int) =>
  ((get b i) - (get a i))%R)) = ((sum_sub_array b lo hi) - (sum_sub_array a
  lo hi))%R).

Parameter numof: (int -> bool) -> int -> int -> int.

Axiom Numof_empty : forall (p:(int -> bool)) (a:int) (b:int), (b <= a)%R ->
  ((numof p a b) = 0%:Z).

Axiom Numof_right_no_add : forall (p:(int -> bool)) (a:int) (b:int),
  (a < b)%R -> ((~ ((p (b - 1%:Z)%R) = true)) -> ((numof p a b) = (numof p a
  (b - 1%:Z)%R))).

Axiom Numof_right_add : forall (p:(int -> bool)) (a:int) (b:int),
  (a < b)%R -> (((p (b - 1%:Z)%R) = true) -> ((numof p a
  b) = (1%:Z + (numof p a (b - 1%:Z)%R))%R)).

Axiom Numof_bounds : forall (p:(int -> bool)) (a:int) (b:int), (a < b)%R ->
  ((0%:Z <= (numof p a b))%R /\ ((numof p a b) <= (b - a)%R)%R).

Axiom Numof_append : forall (p:(int -> bool)) (a:int) (b:int) (c:int),
  ((a <= b)%R /\ (b <= c)%R) -> ((numof p a c) = ((numof p a b) + (numof p b
  c))%R).

Axiom Numof_left_no_add : forall (p:(int -> bool)) (a:int) (b:int),
  (a < b)%R -> ((~ ((p a) = true)) -> ((numof p a b) = (numof p (a + 1%:Z)%R
  b))).

Axiom Numof_left_add : forall (p:(int -> bool)) (a:int) (b:int), (a < b)%R ->
  (((p a) = true) -> ((numof p a b) = (1%:Z + (numof p (a + 1%:Z)%R b))%R)).

Axiom Empty : forall (p:(int -> bool)) (a:int) (b:int), (forall (n:int),
  ((a <= n)%R /\ (n < b)%R) -> ~ ((p n) = true)) -> ((numof p a b) = 0%:Z).

Axiom Full : forall (p:(int -> bool)) (a:int) (b:int), (a <= b)%R ->
  ((forall (n:int), ((a <= n)%R /\ (n < b)%R) -> ((p n) = true)) -> ((numof p
  a b) = (b - a)%R)).

Axiom numof_increasing : forall (p:(int -> bool)) (i:int) (j:int) (k:int),
  ((i <= j)%R /\ (j <= k)%R) -> ((numof p i j) <= (numof p i k))%R.

Axiom numof_strictly_increasing : forall (p:(int -> bool)) (i:int) (j:int)
  (k:int) (l:int), ((i <= j)%R /\ ((j <= k)%R /\ (k < l)%R)) -> (((p
  k) = true) -> ((numof p i j) < (numof p i l))%R).

Axiom numof_change_any : forall (p1:(int -> bool)) (p2:(int -> bool)) (a:int)
  (b:int), (forall (j:int), ((a <= j)%R /\ (j < b)%R) -> (((p1 j) = true) ->
  ((p2 j) = true))) -> ((numof p1 a b) <= (numof p2 a b))%R.

Axiom numof_change_some : forall (p1:(int -> bool)) (p2:(int -> bool))
  (a:int) (b:int) (i:int), ((a <= i)%R /\ (i < b)%R) -> ((forall (j:int),
  ((a <= j)%R /\ (j < b)%R) -> (((p1 j) = true) -> ((p2 j) = true))) ->
  ((~ ((p1 i) = true)) -> (((p2 i) = true) -> ((numof p1 a b) < (numof p2 a
  b))%R))).

Axiom numof_change_equiv : forall (p1:(int -> bool)) (p2:(int -> bool))
  (a:int) (b:int), (forall (j:int), ((a <= j)%R /\ (j < b)%R) -> (((p1
  j) = true) <-> ((p2 j) = true))) -> ((numof p2 a b) = (numof p1 a b)).

(* Why3 assumption *)
Definition is_part (shape:(array int)): Prop :=
  (1%:Z <= (size shape : int))%R /\ ((forall (i:int) (j:int),
  ((0%:Z <= i)%R /\ ((i <= j)%R /\ (j < (size shape : int))%R)) ->
  ((get shape j) <= (get shape i))%R) /\
  (0%:Z <= (get shape ((size shape : int) - 1%:Z)%R))%R).

Axiom is_part_nonneg : forall (sh:(array int)), (is_part sh) ->
  forall (i:int), ((0%:Z <= i)%R /\ (i < (size sh : int))%R) ->
  (0%:Z <= (get sh i))%R.

(* Why3 assumption *)
Definition included (inner:(array int)) (outer:(array int)): Prop :=
  ((size inner : int) = (size outer : int)) /\ forall (i:int),
  ((0%:Z <= i)%R /\ (i < (size outer : int))%R) ->
  ((get inner i) <= (get outer i))%R.

Axiom sum_le_eq : forall (f:(int -> int)) (g:(int -> int)) (a:int) (b:int),
  ((forall (i:int), ((a <= i)%R /\ (i < b)%R) -> ((f i) <= (g i))%R) /\
  ((sum a b f) = (sum a b g))) -> forall (i:int), ((a <= i)%R /\
  (i < b)%R) -> ((f i) = (g i)).

Axiom included_parts_eq : forall (innev:(array int)) (eval:(array int)),
  (included innev eval) -> (((sum_array innev) = (sum_array eval)) ->
  forall (i:int), ((0%:Z <= i)%R /\ (i < (size innev : int))%R) ->
  ((get innev i) = (get eval i))).

Parameter fc: (array int) -> int -> (int -> bool).

Axiom fc_def : forall (a:(array int)) (v:int) (i:int), (((fc a v)
  i) = true) <-> ((get a i) = v).

(* Why3 assumption *)
Definition numeq (a:(array int)) (v:int) (lo:int) (hi:int): int :=
  (numof (fc a v) lo hi).

Axiom numeq_shift : forall (a1:(array int)) (a2:(array int)) (v:int) (lo:int)
  (hi:int), (((0%:Z <= (size a1 : int))%R /\ (0%:Z <= (size a2 : int))%R) /\
  forall (i:int), ((lo <= i)%R /\ (i < hi)%R) ->
  ((get a1 i) = (get a2 (i + 1%:Z)%R))) -> ((numeq a1 v lo hi) = (numeq a2 v
  (lo + 1%:Z)%R (hi + 1%:Z)%R)).

Axiom numeq0 : forall (w:(array int)) (k:int), (forall (i:int),
  ((0%:Z <= i)%R /\ (i < (size w : int))%R) -> ((get w i) < k)%R) ->
  ((numeq w k 0%:Z (size w : int)) = 0%:Z).

(* Why3 assumption *)
Definition valid_input (outer:(array int)) (inner:(array int)): Prop :=
  (included inner outer) /\ ((is_part inner) /\ (is_part outer)).

(* Why3 assumption *)
Definition eq_prefix (s1:(array int)) (s2:(array int)) (i:int): Prop :=
  forall (k:int), ((0%:Z <= k)%R /\ (k < i)%R) -> ((get s1 k) = (get s2 k)).

(* Why3 assumption *)
Definition eq_array (s1:(array int)) (s2:(array int)): Prop :=
  ((size s1 : int) = (size s2 : int)) /\ (eq_prefix s1 s2 (size s1 : int)).

(* Why3 assumption *)
Definition valid_eval (eval:(array int)): Prop :=
  (1%:Z <= (size eval : int))%R /\ ((is_part eval) /\
  ((get eval ((size eval : int) - 1%:Z)%R) = 0%:Z)).

(* Why3 assumption *)
Definition valid_innev (outer:(array int)) (inner:(array int))
  (eval:(array int)) (innev:(array int)) (work:(matrix int)) (row:int)
  (idx:int) (lastinnev:int): Prop := ((0%:Z <= lastinnev)%R /\
  (lastinnev < (size eval : int))%R) /\ ((is_part innev) /\ ((included innev
  eval) /\ ((forall (r:int), ((0%:Z <= r)%R /\ (r < row)%R) ->
  forall (i:int), ((0%:Z <= i)%R /\
  (i < ((get outer r) - (get inner r))%R)%R) ->
  ((0%:Z <= (matrix_get work r i))%R /\
  ((matrix_get work r i) < lastinnev)%R)) /\
  (((row < (size outer : int))%R -> forall (i:int), ((idx < i)%R /\
  (i < ((get outer row) - (get inner row))%R)%R) ->
  ((0%:Z <= (matrix_get work row i))%R /\
  ((matrix_get work row i) < lastinnev)%R)) /\ (((lastinnev = 0%:Z) \/
  (0%:Z < (get innev (lastinnev - 1%:Z)%R))%R) /\ forall (i:int),
  ((lastinnev <= i)%R /\ (i < (size innev : int))%R) ->
  ((get innev i) = 0%:Z)))))).

Axiom is_part_eq : forall (a1:(array int)) (a2:(array int)), (is_part a1) ->
  ((eq_array a1 a2) -> (is_part a2)).

(* Why3 assumption *)
Definition width (outer:(array int)) (inner:(array int)): (int -> int) :=
  fun (r:int) => ((get outer r) - (get inner r))%R.

(* Why3 assumption *)
Definition frame (outer:(array int)) (inner:(array int)) (w1:(matrix int))
  (w2:(matrix int)) (row:int) (idx:int): Prop := (forall (r:int),
  ((0%:Z <= r)%R /\ (r < row)%R) -> forall (i:int), ((0%:Z <= i)%R /\
  (i < ((width outer inner) r))%R) ->
  ((matrix_get w2 r i) = (matrix_get w1 r i))) /\
  ((row < (size outer : int))%R -> forall (i:int), ((idx < i)%R /\
  (i < ((width outer inner) row))%R) ->
  ((matrix_get w2 row i) = (matrix_get w1 row i))).

Axiom valid_innev_framed : forall (outer:(array int)) (inner:(array int))
  (eval:(array int)) (innev:(array int)) (work1:(matrix int))
  (work2:(matrix int)) (row:int) (idx:int) (lastinnev:int), (valid_innev
  outer inner eval innev work1 row idx lastinnev) -> ((frame outer inner
  work1 work2 row idx) -> (valid_innev outer inner eval innev work2 row idx
  lastinnev)).

Axiom frame_weakening : forall (outer:(array int)) (inner:(array int))
  (work1:(matrix int)) (work2:(matrix int)) (row:int) (idx:int), (frame outer
  inner work1 work2 row (idx - 1%:Z)%R) -> (frame outer inner work1 work2 row
  idx).

Axiom frame_trans : forall (outer:(array int)) (inner:(array int))
  (work1:(matrix int)) (work2:(matrix int)) (work3:(matrix int)) (row:int)
  (idx:int), (frame outer inner work1 work2 row idx) -> ((frame outer inner
  work2 work3 row idx) -> (frame outer inner work1 work3 row idx)).

(* Why3 assumption *)
Definition non_decreasing_row_suffix (outer:(array int)) (inner:(array int))
  (work:(matrix int)) (r:int) (start:int): Prop := forall (i1:int) (i2:int),
  ((start <= i1)%R /\ ((i1 <= i2)%R /\ (i2 < ((width outer inner) r))%R)) ->
  ((matrix_get work r i1) <= (matrix_get work r i2))%R.

(* Why3 assumption *)
Definition increasing_column (outer:(array int)) (inner:(array int))
  (work:(matrix int)) (r:int) (i:int): Prop := ((0%:Z < r)%R /\
  (((get inner (r - 1%:Z)%R) - (get inner r))%R <= i)%R) ->
  ((matrix_get work (r - 1%:Z)%R (i - ((get inner (r - 1%:Z)%R) - (get inner r))%R)%R) < (matrix_get work r i))%R.

(* Why3 assumption *)
Definition is_tableau_reading_suffix (outer:(array int)) (inner:(array int))
  (work:(matrix int)) (row:int) (idx:int): Prop := (forall (r:int),
  ((0%:Z <= r)%R /\ (r < row)%R) -> (non_decreasing_row_suffix outer inner
  work r 0%:Z)) /\ (((row < (size outer : int))%R ->
  (non_decreasing_row_suffix outer inner work row (idx + 1%:Z)%R)) /\
  ((forall (r:int), ((1%:Z <= r)%R /\ (r < row)%R) -> forall (i:int),
  ((0%:Z <= i)%R /\ (i < ((get outer r) - (get inner r))%R)%R) ->
  (increasing_column outer inner work r i)) /\
  ((row < (size outer : int))%R -> forall (i:int), ((idx < i)%R /\
  (i < ((get outer row) - (get inner row))%R)%R) -> (increasing_column outer
  inner work row i)))).

(* Why3 assumption *)
Definition is_tableau_reading (outer:(array int)) (inner:(array int))
  (work:(matrix int)): Prop := (is_tableau_reading_suffix outer inner work
  (size outer : int) 0%:Z).

(* Why3 assumption *)
Definition valid_work (outer:(array int)) (inner:(array int))
  (w:(matrix int)): Prop := ((nrows w : int) = (size outer : int)) /\
  forall (r:int), ((0%:Z <= r)%R /\ (r < (size outer : int))%R) ->
  (((get outer r) - (get inner r))%R <= (ncols w : int))%R.

Parameter to_word: (array int) -> (array int) -> (matrix int) -> (array int).

Axiom to_word_size : forall (outer:(array int)) (inner:(array int))
  (w:(matrix int)), (included inner outer) -> ((valid_work outer inner w) ->
  ((size (to_word outer inner w) : int) = (sum 0%:Z (size outer : int)
  (width outer inner)))).

Axiom to_word_contents : forall (outer:(array int)) (inner:(array int))
  (w:(matrix int)), (included inner outer) -> ((valid_work outer inner w) ->
  forall (r:int), ((0%:Z <= r)%R /\ (r < (size outer : int))%R) ->
  forall (i:int), ((0%:Z <= i)%R /\ (i < ((width outer inner) r))%R) ->
  ((get (to_word outer inner w) (i + (sum (r + 1%:Z)%R (size outer : int)
  (width outer inner)))%R) = (matrix_get w r i))).

Axiom valid_to_word_index : forall (outer:(array int)) (inner:(array int))
  (r:int) (i:int), (((0%:Z <= (size outer : int))%R /\
  (0%:Z <= (size inner : int))%R) /\ ((included inner outer) /\
  (((0%:Z <= r)%R /\ (r < (size outer : int))%R) /\ ((0%:Z <= i)%R /\
  (i < ((width outer inner) r))%R)))) -> ((0%:Z <= (i + (sum (r + 1%:Z)%R
  (size outer : int) (width outer inner)))%R)%R /\ ((i + (sum (r + 1%:Z)%R
  (size outer : int) (width outer inner)))%R < (sum 0%:Z (size outer : int)
  (width outer inner)))%R).

(* Why3 assumption *)
Definition is_yam_suffix (w:(array int)) (len:int): Prop := let n :=
  (size w : int) in (((0%:Z <= len)%R /\ (len <= n)%R) /\ ((forall (i:int),
  (((n - len)%R <= i)%R /\ (i < n)%R) -> (0%:Z <= (get w i))%R) /\
  forall (p:int), ((0%:Z <= p)%R /\ (p <= len)%R) -> forall (v1:int)
  (v2:int), ((0%:Z <= v1)%R /\ (v1 <= v2)%R) -> ((numeq w v2 (n - p)%R
  n) <= (numeq w v1 (n - p)%R n))%R)).

(* Why3 assumption *)
Definition is_yam (w:(array int)): Prop := (is_yam_suffix w (size w : int)).

(* Why3 assumption *)
Definition is_of_eval_suffix (eval:(array int)) (w:(array int))
  (len:int): Prop := let n := (size w : int) in ((forall (i:int),
  (((n - len)%R <= i)%R /\ (i < n)%R) -> ((0%:Z <= (get w i))%R /\
  ((get w i) < (size eval : int))%R)) /\ forall (v:int), ((0%:Z <= v)%R /\
  (v < (size eval : int))%R) -> ((numeq w v (n - len)%R
  n) <= (get eval v))%R).

(* Why3 assumption *)
Definition is_of_eval (eval:(array int)) (w:(array int)): Prop := let n :=
  (size w : int) in ((forall (i:int), ((0%:Z <= i)%R /\ (i < n)%R) ->
  ((0%:Z <= (get w i))%R /\ ((get w i) < (size eval : int))%R)) /\
  forall (v:int), ((0%:Z <= v)%R /\ (v < (size eval : int))%R) -> ((numeq w v
  0%:Z n) = (get eval v))).

(* Why3 assumption *)
Definition is_yam_of_eval_suffix (eval:(array int)) (w:(array int))
  (len:int): Prop := (is_yam_suffix w len) /\ (is_of_eval_suffix eval w len).

(* Why3 assumption *)
Definition is_yam_of_eval (eval:(array int)) (w:(array int)): Prop := (is_yam
  w) /\ (is_of_eval eval w).

Axiom is_yam_of_eval_length : forall (eval:(array int)) (w:(array int)),
  (is_yam_of_eval eval w) -> ((size w : int) = (sum_array eval)).

(* Why3 assumption *)
Definition is_solution_suffix (outer:(array int)) (inner:(array int))
  (eval:(array int)) (w:(matrix int)) (row:int) (idx:int): Prop :=
  (valid_work outer inner w) /\ ((((row = (size outer : int)) ->
  (is_yam_of_eval_suffix eval (to_word outer inner w) ((sum 0%:Z row
  (width outer inner)) + 0%:Z)%R)) /\ ((~ (row = (size outer : int))) ->
  (is_yam_of_eval_suffix eval (to_word outer inner w) ((sum 0%:Z row
  (width outer inner)) + ((((width outer inner)
  row) - idx)%R - 1%:Z)%R)%R))) /\ (is_tableau_reading_suffix outer inner w
  row idx)).

(* Why3 assumption *)
Definition is_solution (outer:(array int)) (inner:(array int))
  (eval:(array int)) (w:(matrix int)): Prop := (valid_work outer inner w) /\
  ((is_yam_of_eval eval (to_word outer inner w)) /\ (is_tableau_reading outer
  inner w)).

Axiom sols_pos : forall (outer:(array int)) (inner:(array int))
  (eval:(array int)) (sol:(matrix int)), (included inner outer) ->
  ((is_solution outer inner eval sol) -> forall (r:int) (i:int),
  ((0%:Z <= r)%R /\ (r < (size outer : int))%R) -> (((0%:Z <= i)%R /\
  (i < ((width outer inner) r))%R) -> (0%:Z <= (matrix_get sol r i))%R)).

Axiom solution_length : forall (outer:(array int)) (inner:(array int))
  (eval:(array int)) (w:(matrix int)), (is_solution outer inner eval w) ->
  ((size (to_word outer inner w) : int) = (sum_array eval)).

(* Why3 assumption *)
Definition eq_rows (outer:(array int)) (inner:(array int)) (w1:(matrix int))
  (w2:(matrix int)) (row:int): Prop := forall (r:int), ((0%:Z <= r)%R /\
  (r < row)%R) -> forall (i:int), ((0%:Z <= i)%R /\ (i < ((width outer inner)
  r))%R) -> ((matrix_get w1 r i) = (matrix_get w2 r i)).

(* Why3 assumption *)
Definition lt_sol (outer:(array int)) (inner:(array int)) (w1:(matrix int))
  (w2:(matrix int)): Prop := exists row:int, ((0%:Z <= row)%R /\
  (row < (size outer : int))%R) /\ ((eq_rows outer inner w1 w2 row) /\
  exists col:int, ((0%:Z <= col)%R /\ (col < ((width outer inner) row))%R) /\
  ((forall (i:int), ((col < i)%R /\ (i < ((width outer inner) row))%R) ->
  ((matrix_get w1 row i) = (matrix_get w2 row i))) /\
  ((matrix_get w1 row col) < (matrix_get w2 row col))%R)).

Axiom frame_lt_sol : forall (outer:(array int)) (inner:(array int))
  (w1:(matrix int)) (w2:(matrix int)) (row:int) (idx:int), (frame outer inner
  w1 w2 row idx) -> (((0%:Z <= row)%R /\ (row < (size outer : int))%R) ->
  (((0%:Z <= idx)%R /\ (idx < ((width outer inner) row))%R) ->
  (((matrix_get w1 row idx) < (matrix_get w2 row idx))%R -> (lt_sol outer
  inner w1 w2)))).

(* Why3 assumption *)
Definition eq_sol (outer:(array int)) (inner:(array int)) (w1:(matrix int))
  (w2:(matrix int)): Prop := (eq_rows outer inner w1 w2 (size outer : int)).

Axiom lt_not_eq : forall (outer:(array int)) (inner:(array int))
  (w1:(matrix int)) (w2:(matrix int)), (lt_sol outer inner w1 w2) ->
  ~ (eq_sol outer inner w1 w2).

Axiom solution : Type.

Parameter m2s: (matrix int) -> solution.

Parameter s2m: solution -> (matrix int).

Axiom m2s2m_def : forall (m:(matrix int)), ((s2m (m2s m)) = m).

(* Why3 assumption *)
Inductive solutions :=
  | mk_solutions : (int -> solution)%type -> int -> solutions.

(* Why3 assumption *)
Definition next (v:solutions): int :=
  match v with
  | (mk_solutions x x1) => x1
  end.

(* Why3 assumption *)
Definition sols (v:solutions): (int -> solution)%type :=
  match v with
  | (mk_solutions x x1) => x
  end.

(* Why3 assumption *)
Definition sorted (outer:(array int)) (inner:(array int)) (s:solutions)
  (lo:int) (hi:int): Prop := forall (i:int) (j:int), ((lo <= i)%R /\
  ((i < j)%R /\ (j < hi)%R)) -> (lt_sol outer inner (s2m ((sols s) i))
  (s2m ((sols s) j))).

Axiom no_duplicate : forall (outer:(array int)) (inner:(array int))
  (s:solutions) (lo:int) (hi:int), (sorted outer inner s lo hi) ->
  forall (i:int) (j:int), ((lo <= i)%R /\ ((i < j)%R /\ (j < hi)%R)) ->
  ~ (eq_sol outer inner (s2m ((sols s) i)) (s2m ((sols s) j))).

(* Why3 assumption *)
Definition good_solutions (outer:(array int)) (inner:(array int))
  (eval:(array int)) (s:solutions): Prop := (0%:Z <= (next s))%R /\ ((sorted
  outer inner s 0%:Z (next s)) /\ ((forall (i:int), ((0%:Z <= i)%R /\
  (i < (next s))%R) -> (is_solution outer inner eval (s2m ((sols s) i)))) /\
  forall (w:(matrix int)), (is_solution outer inner eval w) -> exists i:int,
  ((0%:Z <= i)%R /\ (i < (next s))%R) /\ (eq_sol outer inner w
  (s2m ((sols s) i))))).

